<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<script type="text/javascript">alert = function() {};</script>
<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDtlKIl02bk1ebAl4zYhC3gx5l5BkzxSSQ&sensor=false"></script>
<script type="text/javascript" src="jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="pako_inflate.min.js"></script>
<script type="text/javascript" src="sylvester.js"></script>
</head>
<body style="background-color:#000;">

<table style="width:100%; height:100%; color:#fff; font-family: sans-serif; font-size: smaller;">
<tr><td style="text-align:center; font-weight:bold;">Move: W A S D, Look: Cursor keys&nbsp;&nbsp;&nbsp;<a href="javascript:void(0)" style="color:#ccf;" onclick="if($('#ctrlCont').is(':visible')) {$('#ctrlCont').hide(); $(this).text('Show buttons');} else {$('#ctrlCont').show(); $(this).text('Hide buttons');} setTimeout(update, 1);">Show buttons</a>&nbsp;&nbsp;&nbsp;<a href="javascript:void(0)" style="color:#ccf;" onclick="if(qualityMode) {qualityMode = false; $(this).text('HQ OFF');} else {qualityMode = true; $(this).text('HQ ON');} forceLoad = true; setTimeout(load, 1);">HQ OFF</a></td></tr>
<tr><td id="outCont" style="text-align:center; height:100%;">
<div id="fail_js">You have to enable Javascript in your browser!</div>
<div id="fail_data" style="display:none;">Sorry, no Street View data found for this address!</div>
<div id="fail_query" style="display:none;">Specify the address or location in the browser's address bar, e.g. <span style="color:#ccf;">https://streetview3d.github.io/view.htm?loc=</span> or <span style="color:#ccf;">https://streetview3d.github.io/view.htm?loc=</span></div>
<div id="fail_gen" style="display:none;">Something went wrong...</div>
<div id="fail_key" style="display:none;">Sorry, it seems that Google has revoked my API Key...</div>
<canvas id="outImg">You have to look for a browser, which supports HTML5!</canvas>
</td></tr>
<tr><td><div id="ctrlCont" style="text-align:center; font-weight:bold; white-space:nowrap; display:none;">
Move:
<input type="button" value="<" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(65)" onmouseup="keyupHandler(65)" onmouseout="keyupHandler(65)" />
&nbsp;
<input type="button" value="/\" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(87)" onmouseup="keyupHandler(87)" onmouseout="keyupHandler(87)" />
&nbsp;
<input type="button" value="\/" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(83)" onmouseup="keyupHandler(83)" onmouseout="keyupHandler(83)" />
&nbsp;
<input type="button" value=">" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(68)" onmouseup="keyupHandler(68)" onmouseout="keyupHandler(68)" />
&nbsp;
Look:
<input type="button" value="<" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(37)" onmouseup="keyupHandler(37)" onmouseout="keyupHandler(37)" />
&nbsp;
<input type="button" value="/\" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(40)" onmouseup="keyupHandler(40)" onmouseout="keyupHandler(40)" />
&nbsp;
<input type="button" value="\/" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(38)" onmouseup="keyupHandler(38)" onmouseout="keyupHandler(38)" />
&nbsp;
<input type="button" value=">" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(39)" onmouseup="keyupHandler(39)" onmouseout="keyupHandler(39)" />
</div></td></tr>
</table>

<script type="text/javascript">

// TODO fail location

// TODO aspect ratio
// TODO check fail,browser,os,modes,z-sort,gaps,coeffs
// TODO check format, todos, comments
// TODO readme

// TODO minwallradius smooth

// global accessible functions and initialization

var load = function() {},
	update = function() {},
	keydownHandler = function() {},
	keyupHandler = function() {},
	qualityMode = false,
	forceLoad = false;
$(function() {

var abortOnFail = false;
$('#fail_js').hide();

jQuery.fx.interval = Math.max(jQuery.fx.interval, 50);

// convert polar coordinates to equirectangular projection

function radialCoord(center, angle, radius) {
	return [
		center[0] + Math.cos(angle) * radius,
		center[1] + Math.sin(angle) * radius
	];
}

// normalize radian to the range from 0 to 2*pi

function normalizeRad(radian) {
	return ((radian) % (Math.PI*2) + (Math.PI*2)) % (Math.PI*2);
}

// convert degree to radian

function deg2rad(degree) {
	return normalizeRad(degree * (Math.PI/180));
}

// copy triangle from one buffer to another and apply affine transformation
// coordinates are extrapolated to remove gaps between polygons

function transformTriangle(srcImg, srcCoords, dstCtx, dstCoords, wireframe) {
	dstCtx.save();

	for(var i = 0; i < 2; ++i) {
		var vec1 = [
				$V((i ? dstCoords : srcCoords)[0]),
				$V((i ? dstCoords : srcCoords)[1]),
				$V((i ? dstCoords : srcCoords)[2])
			],
			middle = vec1[0].add(vec1[1]).add(vec1[2]).x(1/3).elements,
			vec2 = [
				vec1[1].subtract(vec1[0]),
				vec1[2].subtract(vec1[1]),
				vec1[0].subtract(vec1[2])
			],
			pre1 = [
				vec1[1].distanceFrom(vec1[2]),
				vec1[2].distanceFrom(vec1[0]),
				vec1[0].distanceFrom(vec1[1]),
				Math.cos((Math.PI/2) - vec2[0].angleFrom(vec2[2].x(-1)) / 2),
				Math.cos((Math.PI/2) - vec2[1].angleFrom(vec2[0].x(-1)) / 2),
				Math.cos((Math.PI/2) - vec2[2].angleFrom(vec2[1].x(-1)) / 2)
			],
			center = vec1[0].x(pre1[0]).add(vec1[1].x(pre1[1])).add(vec1[2].x(pre1[2])).x(1 / (pre1[0] + pre1[1] + pre1[2])),
			pre2 = [
				vec1[0].subtract(center),
				vec1[1].subtract(center),
				vec1[2].subtract(center),
				vec1[0].distanceFrom(center),
				vec1[1].distanceFrom(center),
				vec1[2].distanceFrom(center)
			];
	
		for(var j = 0; j < 3; ++j) {
			(i ? dstCoords : srcCoords)[j] = pre2[j].x((pre2[j + 3] + Math.min((i ? 1/2 : 1/4) / pre1[j + 3], (i ? 3 : 3))) / pre2[j + 3]).add(center).elements;
		}
	}
	for(var j = 0; j < 3; ++j) {
		srcCoords[j][0] = Math.max(srcCoords[j][0], 0);
		srcCoords[j][0] = Math.min(srcCoords[j][0], srcImg.width);
		srcCoords[j][1] = Math.max(srcCoords[j][1], 0);
		srcCoords[j][1] = Math.min(srcCoords[j][1], srcImg.height);
	}
	
	dstCtx.beginPath();
	dstCtx.moveTo(dstCoords[0][0], dstCoords[0][1]);
	dstCtx.lineTo(dstCoords[1][0], dstCoords[1][1]);
	dstCtx.lineTo(dstCoords[2][0], dstCoords[2][1]);
	dstCtx.closePath();
	dstCtx.clip();
	
	var x0 = dstCoords[0][0],
		y0 = dstCoords[0][1],
		x1 = dstCoords[1][0] - x0,
		y1 = dstCoords[1][1] - y0,
		x2 = dstCoords[2][0] - x0,
		y2 = dstCoords[2][1] - y0,
		u0 = srcCoords[0][0],
		v0 = srcCoords[0][1],
		u1 = srcCoords[1][0] - u0,
		v1 = srcCoords[1][1] - v0,
		u2 = srcCoords[2][0] - u0,
		v2 = srcCoords[2][1] - v0;
	
	var denom = (u1*v2 - u2*v1);
	if(denom != 0) {
		var det = 1 / denom,
			a = (v2*x1 - v1*x2) * det,
			b = (v2*y1 - v1*y2) * det,
			c = (u1*x2 - u2*x1) * det,
			d = (u1*y2 - u2*y1) * det,
			e = x0 - a*u0 - c*v0,
			f = y0 - b*u0 - d*v0;
		
		dstCtx.transform(a, b, c, d, e, f);
		
		var bx0 = Math.max(Math.floor(Math.min(srcCoords[0][0], srcCoords[1][0], srcCoords[2][0])), 0),
			by0 = Math.max(Math.floor(Math.min(srcCoords[0][1], srcCoords[1][1], srcCoords[2][1])), 0),
			bx1 = Math.min(Math.ceil(Math.max(srcCoords[0][0], srcCoords[1][0], srcCoords[2][0])), srcImg.width),
			by1 = Math.min(Math.ceil(Math.max(srcCoords[0][1], srcCoords[1][1], srcCoords[2][1])), srcImg.height);
		dstCtx.drawImage(srcImg, bx0, by0, bx1 - bx0, by1 - by0, bx0, by0, bx1 - bx0, by1 - by0);
	}
	
	dstCtx.restore();
	
	/*if(wireframe) {
		dstCtx.strokeStyle = '#fff';
		dstCtx.lineWidth = 1;
		dstCtx.beginPath();
		dstCtx.moveTo(dstCoords[0][0],dstCoords[0][1]);
		dstCtx.lineTo(dstCoords[1][0],dstCoords[1][1]);
		dstCtx.lineTo(dstCoords[2][0],dstCoords[2][1]);
		dstCtx.closePath();
		dstCtx.stroke();
	}*/
}

// same, but segment quad first

function transformQuad1(srcCtx, srcCoords, dstCtx, dstCoords, center) {
	if(qualityMode) {
		var quads = qualitySegment([[srcCoords,dstCoords,null]]);
		for(var i = 0; i < 4; ++i) {
			transformQuad2(srcCtx, quads[i][0], dstCtx, quads[i][1], (center && i < 2));
		}
	}
	else {
		transformQuad2(srcCtx, srcCoords, dstCtx, dstCoords, center);
	}
}

function transformQuad2(srcCtx, srcCoords, dstCtx, dstCoords, center) {
	var srcMiddle = $V(srcCoords[0]).add($V(srcCoords[1])).add($V(srcCoords[2])).add($V(srcCoords[3])).x(1/4).elements,
		dstMiddle = $V(dstCoords[0]).add($V(dstCoords[1])).add($V(dstCoords[2])).add($V(dstCoords[3])).x(1/4).elements;
	transformTriangle(srcCtx, [srcCoords[0], srcCoords[1], srcMiddle], dstCtx, [dstCoords[0], dstCoords[1], dstMiddle], false);
	transformTriangle(srcCtx, [srcCoords[1], srcCoords[2], srcMiddle], dstCtx, [dstCoords[1], dstCoords[2], dstMiddle], false);
	transformTriangle(srcCtx, [srcCoords[2], srcCoords[3], srcMiddle], dstCtx, [dstCoords[2], dstCoords[3], dstMiddle], false);
	if(!center)
		transformTriangle(srcCtx, [srcCoords[3], srcCoords[0], srcMiddle], dstCtx, [dstCoords[3], dstCoords[0], dstMiddle], false);
}

// segment quads for quality mode

function qualitySegment(quads1) { // TODO central ground
	var quads2 = [];
	
	for(var i = 0; i < quads1.length; ++i) {
		var srcVec = [
				$V(quads1[i][0][0]),
				$V(quads1[i][0][1]),
				$V(quads1[i][0][2]),
				$V(quads1[i][0][3])
			],
			srcPoint = [
				[
					srcVec[0].elements,
					srcVec[0].add(srcVec[3]).x(1/2).elements,
					srcVec[3].elements,
				],
				[
					srcVec[0].add(srcVec[1]).x(1/2).elements,
					null,
					srcVec[3].add(srcVec[2]).x(1/2).elements
				],
				[
					srcVec[1].elements,
					srcVec[1].add(srcVec[2]).x(1/2).elements,
					srcVec[2].elements,
				]
			],
			dstVec = [
				$V(quads1[i][1][0]),
				$V(quads1[i][1][1]),
				$V(quads1[i][1][2]),
				$V(quads1[i][1][3])
			],
			dstPoint = [
				[
					dstVec[0].elements,
					dstVec[0].add(dstVec[3]).x(1/2).elements,
					dstVec[3].elements,
				],
				[
					dstVec[0].add(dstVec[1]).x(1/2).elements,
					null,
					dstVec[3].add(dstVec[2]).x(1/2).elements
				],
				[
					dstVec[1].elements,
					dstVec[1].add(dstVec[2]).x(1/2).elements,
					dstVec[2].elements,
				]
			];
			srcPoint[1][1] = $V(srcPoint[1][0]).add($V(srcPoint[1][2])).x(1/2).elements;
			dstPoint[1][1] = $V(dstPoint[1][0]).add($V(dstPoint[1][2])).x(1/2).elements;
		quads2.push([
			[srcPoint[0][0], srcPoint[1][0], srcPoint[1][1], srcPoint[0][1]],
			[dstPoint[0][0], dstPoint[1][0], dstPoint[1][1], dstPoint[0][1]],
			quads1[i][2]
		]);
		quads2.push([
			[srcPoint[0][1], srcPoint[1][1], srcPoint[1][2], srcPoint[0][2]],
			[dstPoint[0][1], dstPoint[1][1], dstPoint[1][2], dstPoint[0][2]],
			quads1[i][2]
		]);
		quads2.push([
			[srcPoint[1][0], srcPoint[2][0], srcPoint[2][1], srcPoint[1][1]],
			[dstPoint[1][0], dstPoint[2][0], dstPoint[2][1], dstPoint[1][1]],
			quads1[i][2]
		]);
		quads2.push([
			[srcPoint[1][1], srcPoint[2][1], srcPoint[2][2], srcPoint[1][2]],
			[dstPoint[1][1], dstPoint[2][1], dstPoint[2][2], dstPoint[1][2]],
			quads1[i][2]
		]);
	}
	
	return quads2;
}

// floating point number decoder

function Bytes2Float32(bytes) {
	var sign = (bytes & 0x80000000) ? -1 : 1,
		exponent = ((bytes >> 23) & 0xFF) - 127,
		significand = (bytes & ~(-1 << 23));
	
	if(exponent == 128)
		return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);
	
	if(exponent == -127) {
		if(significand == 0) return sign * 0.0;
		exponent = -126;
		significand /= (1 << 22);
	} else significand = (significand | (1 << 23)) / (1 << 23);
	
	return sign * significand * Math.pow(2, exponent);
}

// query parameter extraction

function getParam(param) {
	regex = new RegExp('[\\?&]' + param + '=([^&#]*)'),
		result = regex.exec(location.search);
	return result == null ? '' : decodeURIComponent(result[1].replace(/\+/g, ' '));
}

// global state

var viewPos = [.07,.03],
	loadPos = viewPos,
	loadDistPos = [0,0],
	loadDist = 1,
	viewRot = [0,-deg2rad(90)],
	latLng = null,
	panoId = null,
	centerHeading = null;

// configure initial heading

switch(getParam('turn')) { // TODO n,e,s,w
case 'n':
break;
case 'e':
break;
case 's':
break;
case 'w':
break;
}
	viewRot[1] += deg2rad(180);

// constant query parameters

var zoomLevel = 3,
	panoSize = [416 << zoomLevel,(416 << zoomLevel) >> 1],
	tileSize = [512, 512],
	tex1Size = [panoSize[0],panoSize[1] >> 1],
	tex2Size = [panoSize[0] >> 1,panoSize[0] >> 1];

// global coeffs

var coeff = { // TODO
	wallNum: 32,
	groundRadius: 80,
	minWallRadius: 10,
	maxWallRadius: 70,
	maxWallRadius2: 100,
	minLinkRadius: 20,
	maxLinkRadius: 80,
	wallHeight: 80,
	camHeight: 2.75,
	loadDistQuota: 2, 
	maxLoadDist: 80,
	skipTolerance: deg2rad(45),
	compassTolerance: deg2rad(135/2),
	moveSpeed: 1.5,
	moveSpeedLoading: 0.75,
	viewYawStep: deg2rad(360/32),
	viewPitchStep: deg2rad(90/8),
	compassSizeQuota: 32,
	keyInterval: 100,
	keyIntervalLoadingMult: 5,
	segmentNearDist: 20,
	mergeWallsDist: 40,
	mergeWallsTolerance: 5,
	removeTreeDist: 20,
	removeTreeQuota: 2,
	loadWallPitchNum: 4,
	loadGroundPitchNum: 4,
	loadGroundYawStart: 4,
	loadGroundYawStartQuality: 8,
	groundTblMax: 8,
	groundTbl: [
		-8,
		-3,
		-1,
		0,
		1,
		3,
		8
	],
	ceilingTblMax: 8,
	ceilingTbl: [
		-8,
		-3,
		0,
		3,
		8
	]
};

// loaded resources

var texImg2 = null,
	tex2 = null,
	walls3 = null,
	links3 = [];

// panorama load routine

var isLoading = false;

load = function() {

	// handle concurrent event
	
	if(isLoading)
		return;
	isLoading = true;
	
	// check link proximity and direction
	
	var linkPos = [0,0],
		previousCenterHeading = centerHeading,
		nearestAngle = coeff.compassTolerance;
	for(var i = 0; i < links3.length; ++i) {
		var posLinkDist = $V(loadPos).distanceFrom($V(links3[i][1])),
			posCenterDist = $V(loadPos).distanceFrom(Vector.Zero(2)),
			moveAngle = $V(loadPos).subtract($V(viewPos)).angleFrom($V(links3[i][1]));
		if(posLinkDist < posCenterDist
		&& nearestAngle > moveAngle) {
			nearestAngle = moveAngle;
			panoId = links3[i][0];
			linkPos = links3[i][1];
		}
	}
	
	if(!forceLoad && panoId != null && nearestAngle == coeff.compassTolerance) {
		isLoading = false;
		return;
	}
	forceLoad = false;
	
	// declare temporary buffers
	
	var texImg1 = [
		document.createElement('canvas'),
		document.createElement('canvas'),
		document.createElement('canvas')
	];
	
	texImg1[0].width = tex1Size[0];
	texImg1[0].height = tex1Size[1];
	texImg1[1].width = tex2Size[0];
	texImg1[1].height = tex2Size[1];
	texImg1[2].width = tex2Size[0];
	texImg1[2].height = tex2Size[1];
	
	var tex1 = [
		texImg1[0].getContext('2d'),
		texImg1[1].getContext('2d'),
		texImg1[2].getContext('2d')
	];
	
	var keyValid = false,
		panoImg,
		walls1,
		links1 = [],
		links2 = [];
	
	// manage and serialize asynchronous calls
	
	var step = 0;
	function next() {
		if(step < steps.length)
			setTimeout(steps[step++], 1);
	}
	var steps = [
		
		// load panoId for address or use an explicit one
		
		function() {
			var query = getParam('loc');
			if(!query.length) {
				$('#fail_query').show();
				$('#outImg').hide();
				abortOnFail = true;
				throw null;
			}
			
			setTimeout(function() {
				if(!keyValid)
					$('#fail_key').show();
			}, 4000);
			
			if(panoId != null) {
				next();
			}
			else {
				new google.maps.Geocoder().geocode(
					{
						address: query
					},
					function(data) {
						try {
							latLng = data[0].geometry.location;
						}
						catch(e) {
							$('#fail_data').show();
							$('#fail_query').show();
							$('#outImg').hide();
							abortOnFail = true;
							throw e;
						}
						
						next();
					}
				);
			}
		},
		
		// load panorama details
		
		function() {
			var success = function(data) {
				keyValid = true;
				$('#fail_key').hide();
				
				try {
					panoId = data.location.pano;
					centerHeading = deg2rad(data.tiles.centerHeading);
				}
				catch(e) {
					$('#fail_data').show();
					$('#fail_query').show();
					$('#outImg').hide();
					abortOnFail = true;
					throw e;
				}
				
				next();
			}
			
			if(panoId != null) {
				new google.maps.StreetViewService().getPanoramaById(
					panoId,
					success
				);
			}
			else {
				new google.maps.StreetViewService().getPanoramaByLocation(
					latLng,
					50,
					success
				);
			}
		},
		
		// load depth map
		
		function() {
			$.ajax({
				url: 'https://maps.google.com/cbk?output=json&dm=1&pm=1&ph=1&panoid='+panoId,
				dataType: 'jsonp',
				error: function() {
					throw null;
				},
				success: function(data) {
					latLng = new google.maps.LatLng(data.Location.original_lat, data.Location.original_lng);
					
					for(var i = 0; i < data.Links.length; ++i) {
						links1[i] = [
							data.Links[i].panoId,
							latLng,
							deg2rad(parseFloat(data.Links[i].yawDeg)),
							Vector.Zero(2)
						];
					}
					
					var depthMap1 = data.model.depth_map;
					
					depthMap1 = depthMap1.replace(/-/g,'+');
					depthMap1 = depthMap1.replace(/_/g,'/');
					depthMap1 = atob(depthMap1);
					depthMap1 = pako.inflate(depthMap1);
					
					var planeCount = (depthMap1[2] << 8) | depthMap1[1],
						width = (depthMap1[4] << 8) | depthMap1[3],
						height = (depthMap1[6] << 8) | depthMap1[5],
						offset = (depthMap1[8] << 8) | depthMap1[7];
					
					var depthMap2 = [];
					for(var i = 0; i < planeCount; ++i) {
						depthMap2[i] = [];
						for(var j = 0; j < 4; ++j) {
							var pos = width * height + offset + i * 16 + j * 4;
							depthMap2[i][j] = Bytes2Float32((depthMap1[pos+3] << 24) | (depthMap1[pos+2] << 16) | (depthMap1[pos+1] << 8) | depthMap1[pos]);
						}
					}
					
					var depthMap4 = [];
					for(var yaw = 0; yaw < coeff.wallNum; ++yaw) {
						var depthMap3 = [];
						for(var pitch = 0; pitch < 3; ++pitch) {
							var x = yaw * width / coeff.wallNum,
								y = height / 2 - pitch * height / coeff.wallNum,
								index = depthMap1[offset + y * width + x],
								depth = coeff.maxWallRadius2;
							if(index > 0) {
								var phi = (width - x - 1) / (width - 1) * 2 * (Math.PI) + (Math.PI/2),
									theta = (height - y - 1) / (height - 1) * (Math.PI),
									v = [
										Math.sin(theta) * Math.cos(phi),
										Math.sin(theta) * Math.sin(phi),
										Math.cos(theta)
									],
									plane = depthMap2[index],
									t = plane[3] / (v[0]*plane[0] + v[1]*plane[1] + v[2]*plane[2]);
								v[0] *= t;
								v[1] *= t;
								v[2] *= t;
								depth = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
								depth = Math.max(depth, coeff.minWallRadius);
								depth = Math.min(depth, coeff.maxWallRadius2);
							}
							depthMap3[pitch] = depth;
						}
						
						depthMap4[yaw] = (depthMap3[0]*4 + depthMap3[1]*2 + depthMap3[2]) / 7;
						depthMap4[yaw] = Math.min(depthMap4[yaw], coeff.maxWallRadius);
					}
					
					var depthMap5 = [];
					for(var yaw = 0; yaw < coeff.wallNum; ++yaw) {
						var middle = (depthMap4[(yaw + coeff.wallNum - 1) % coeff.wallNum] + depthMap4[(yaw + 1) % coeff.wallNum]) / 2,
							amount = Math.abs(depthMap4[yaw] - middle);
						if(amount >= coeff.removeTreeDist
						&& Math.abs(depthMap4[(yaw + coeff.wallNum - 1) % coeff.wallNum] - depthMap4[(yaw + 1) % coeff.wallNum]) <= amount / coeff.removeTreeQuota) {
							depthMap5[yaw] = middle;
						}
						else {
							depthMap5[yaw] = depthMap4[yaw];
						}
					}
					
					walls1 = depthMap5;
					
					next();
				}
			});
		},
		
		// load panorama bitmap
		
		function() {
			panoImg = document.createElement('canvas');
			panoImg.width = panoSize[0];
			panoImg.height = panoSize[1];
			
			var nextCtr = 1;
			for(var y1 = 0, y2 = 0; y2 < panoSize[1]; ++y1, y2 += tileSize[1]) {
				for(var x1 = 0, x2 = 0; x2 < panoSize[0]; ++x1, x2 += tileSize[0]) {
					nextCtr++;
					(function(x1,x2,y1,y2) {
						var tileImg = new Image();
						tileImg.onload = function() {
							panoImg.getContext('2d').drawImage(tileImg,x2,y2);
							
							if(!--nextCtr)
								next();
						}
						tileImg.onerror = function() {
							throw null;
						}
						tileImg.src = 'https://cbk0.google.com/cbk?output=tile&zoom='+zoomLevel+'&x='+x1+'&y='+y1+'&panoid='+panoId;
					})(x1,x2,y1,y2);
				}
			}
			
			if(!--nextCtr)
				next();
		},
		
		// load links

		// TODO missing links
		
		function() {
			var nextCtr = 1;
			
			for(var i = 0; i < links1.length; ++i) {
				nextCtr++;
				function nextLink(link) {
					$.ajax({
						url: 'https://maps.google.com/cbk?output=json&dm=1&pm=1&ph=1&panoid='+link[0],
						dataType: 'jsonp',
						error: function() {
							throw null;
						},
						success: function(data) {
							var dist1 = google.maps.geometry.spherical.computeDistanceBetween(link[1], new google.maps.LatLng(data.Location.original_lat, data.Location.original_lng)),
								heading1 = normalizeRad(link[2] - centerHeading - deg2rad(90)),
								vec = $V([0,dist1]).rotate(-heading1, [0,0]);
							
							link[3] = link[3].add(vec);
							
							var dist2 = link[3].distanceFrom(Vector.Zero(2));

							if(dist2 < coeff.maxLinkRadius && data.Links.length == 2) {
								for(var i = 0; i < data.Links.length; ++i) {
									var heading2 = deg2rad(parseFloat(data.Links[i].yawDeg));
									
									if(Math.abs(link[2] - heading2) < coeff.skipTolerance
									|| Math.abs(link[2] - heading2) > normalizeRad(-coeff.skipTolerance)) {
										link = [
											data.Links[i].panoId,
											new google.maps.LatLng(data.Location.original_lat, data.Location.original_lng),
											heading2,
											link[3]
										];
										nextLink(link);
										return;
									}
								}
							}
							
							{
								if(dist2 < coeff.minLinkRadius)
									link[3] = link[3].x(dist2/coeff.minLinkRadius);
								if(dist2 > coeff.maxLinkRadius)
									link[3] = link[3].x(coeff.maxLinkRadius/dist2);
								
								links2.push([
									link[0],
									link[3].elements,
									normalizeRad(Math.atan2(link[3].elements[1], link[3].elements[0]) - deg2rad(90))
								]);
								
								if(!--nextCtr)
									next();
							}
						}
					});
				}
				nextLink(links1[i]);
			}
			
			if(!--nextCtr)
				next();
		},
		
		// prepare ground, ceiling and wall textures
		
		function() {
			var nextCtr = 1,
				callList1 = [],
				callList2 = [];
			
			function async1() {
				if(callList1.length == 0)
					return;
				
				var params = callList1.pop(),
					ceiling = params[0],
					yaws = params[1],
					pitch = params[2],
					pitch1 = params[3],
					pitch2 = params[4];
					
				for(var yaw = 0; yaw < yaws; ++yaw) {
					var pre = [
						panoImg.width / yaws,
						1 / (1 << (coeff.loadGroundPitchNum - 1)) * coeff.wallHeight / (ceiling ? (coeff.wallHeight - coeff.camHeight) : coeff.camHeight),
						1 / (Math.PI/2) * panoImg.height / 2,
						1 / yaws * (Math.PI*2),
						Math.cos(1 / yaws * (Math.PI*2)),
						1 / (1 << (coeff.loadGroundPitchNum - 1)) * tex2Size[0] / 2,
						[tex2Size[0] / 2,tex2Size[1] / 2]
					],
					srcCoords1 = [
						yaw * pre[0],
						(yaw+1) * pre[0],
						Math.atan(pitch1 * pre[1]) * pre[2],
						Math.atan(pitch2 * pre[1]) * pre[2]
					],
					srcCoords2 = [
						ceiling ? srcCoords1[2] : panoImg.height - srcCoords1[2],
						ceiling ? srcCoords1[3] : panoImg.height - srcCoords1[3]
					],
					srcCoords3 = [
						[srcCoords1[0], srcCoords2[0]],
						[srcCoords1[0], srcCoords2[1]],
						[srcCoords1[1], srcCoords2[1]],
						[srcCoords1[1], srcCoords2[0]]
					],
					dstCoords1 = [
						yaw * pre[3],
						(yaw+1) * pre[3],
						pitch1 * pre[5],
						pitch2 * pre[5]
					],
					dstCoords2 = [
						dstCoords1[2] * ((yaw % 2) ? pre[4] : 1),
						dstCoords1[2] * ((!(yaw % 2)) ? pre[4] : 1)
					],
					dstCoords3 = [
						radialCoord(pre[6], dstCoords1[0], dstCoords2[0]),
						radialCoord(pre[6], dstCoords1[0], dstCoords1[3]),
						radialCoord(pre[6], dstCoords1[1], dstCoords1[3]),
						radialCoord(pre[6], dstCoords1[1], dstCoords2[1])
					];
					transformQuad1(panoImg, srcCoords3, ceiling ? tex1[2] : tex1[1], dstCoords3, !pitch);
				}
				
				setTimeout(async1, 1);
				
				if(!--nextCtr)
					next();
			}
			
			for(var ceiling = 0; ceiling < 2; ++ceiling) {
				for(var pitch = 0; pitch < coeff.loadGroundPitchNum; ++pitch) {
					var pitch2 = 1 << pitch,
						pitch1 = pitch2 >> 1,
						yaws = (qualityMode ? coeff.loadGroundYawStartQuality : coeff.loadGroundYawStart) << pitch;
					
					nextCtr++;
					callList1.push([ceiling, yaws, pitch, pitch1, pitch2]);
				}
			}
			
			function async2() {
				if(callList2.length == 0)
					return;
				
				var params = callList2.pop(),
					pitch = params[0];
				
				for(var yaw = 0; yaw < coeff.wallNum; ++yaw) {
					var pre = [
						panoImg.width / coeff.wallNum,
						1 / (Math.PI/2) * panoImg.height / 2
					],
					srcCoords1 = [
						yaw * pre[0],
						(yaw+1) * pre[0],
						(pitch * (coeff.wallHeight / coeff.loadWallPitchNum) - coeff.camHeight),
						((pitch+1) * (coeff.wallHeight / coeff.loadWallPitchNum) - coeff.camHeight),
						walls1[yaw],
						walls1[(yaw+1) % coeff.wallNum]
					],
					srcCoords2 = [
						panoImg.height / 2 - Math.atan(srcCoords1[2] / srcCoords1[4]) * pre[1],
						panoImg.height / 2 - Math.atan(srcCoords1[3] / srcCoords1[4]) * pre[1],
						panoImg.height / 2 - Math.atan(srcCoords1[3] / srcCoords1[5]) * pre[1],
						panoImg.height / 2 - Math.atan(srcCoords1[2] / srcCoords1[5]) * pre[1]
					],
					srcCoords3 = [
						[srcCoords1[0], srcCoords2[0]],
						[srcCoords1[0], srcCoords2[1]],
						[srcCoords1[1], srcCoords2[2]],
						[srcCoords1[1], srcCoords2[3]]
					],
					dstCoords1 = [
						yaw * pre[0],
						(yaw+1) * pre[0],
						tex1Size[1] - pitch * tex1Size[1] / coeff.loadWallPitchNum,
						tex1Size[1] - (pitch+1) * tex1Size[1] / coeff.loadWallPitchNum
					],
					dstCoords2 = [
						[dstCoords1[0], dstCoords1[2]],
						[dstCoords1[0], dstCoords1[3]],
						[dstCoords1[1], dstCoords1[3]],
						[dstCoords1[1], dstCoords1[2]]
					];
					transformQuad1(panoImg, srcCoords3, tex1[0], dstCoords2, false);
				}
				
				setTimeout(async2, 1);
				
				if(!--nextCtr)
					next();
			}
			
			for(var pitch = 0; pitch < coeff.loadWallPitchNum; ++pitch) {
				nextCtr++;
				callList2.push([pitch]);
			}
			
			setTimeout(async1, 1);
			setTimeout(async2, 1);
			
			if(!--nextCtr)
				next();
		},
		
		// finish loading and initiate update
		
		function() {
			var rotDiff = previousCenterHeading == null ? 0 : normalizeRad(previousCenterHeading - centerHeading),
				vec = $V(viewPos).subtract($V(linkPos)).rotate(-rotDiff, [0,0]);
			loadPos = viewPos = vec.elements; // TODO
			viewRot[1] += rotDiff;
			
			var walls2 = [],
				mergeNext = false;
			for(var i = 0; i < coeff.wallNum; ++i) {
				if(mergeNext
				&& i > 0 && i < (coeff.wallNum - 1)
				&& walls1[i - 1] <= coeff.mergeWallsDist && walls1[i] <= coeff.mergeWallsDist && walls1[i + 1] <= coeff.mergeWallsDist
				&& Math.abs(walls1[i - 1] - walls1[i + 1]) <= coeff.mergeWallsTolerance) {
					mergeNext = false;
					continue;
				}
				
				walls2.push([
					radialCoord([0,0], -(i / coeff.wallNum * (Math.PI*2)), walls1[i]),
					i
				]);
				mergeNext = true;
			}
			
			tex2 = tex1;
			texImg2 = texImg1;
			links3 = links2;
			walls3 = walls2;
			
			isLoading = false;
			
			fade = true;
			setTimeout(update, 1);
		}
	];
	
	// begin with first step
	
	next();
}

// display update routine

var isUpdating = false,
	requiresUpdate = false,
	fade = false;

update = function() {
	if(tex2 == null || texImg2 == null || walls3 == null)
		return;
	
	// handle concurrent event
	
	requiresUpdate = true;
	if(isUpdating)
		return;
	isUpdating = true;
	requiresUpdate = false;
	
	// update dimensions, set canvas properties and clear buffer
	
	var btnSize = $('body').width()/20;
	$('.btn').width(btnSize);
	$('.btn').height(btnSize);
	
	var outImg = $('#outImg')[0];
	outImg.width = 1;
	outImg.height = 1;
	var outSize = [
		Math.min($('#outCont').width(), $('#outCont').height()/3*4),
		Math.min($('#outCont').height(), $('#outCont').width()/4*3)
	];
	
	var bufImg = document.createElement('canvas');
	bufImg.width = outSize[0];
	bufImg.height = outSize[1];
	var buf = bufImg.getContext('2d');
	
	outImg.width = outSize[0];
	outImg.height = outSize[1];
	var out = outImg.getContext('2d');
	
	buf.fillStyle = '#000';
	buf.fillRect(0, 0, outSize[0], outSize[1]);
	
	// view translation and projection matrices
	
	var vec = $V(viewPos),
		dist = vec.distanceFrom(Vector.Zero(2));
	if(dist > coeff.maxWallRadius) {
		vec = vec.x(coeff.maxWallRadius/dist);
		viewPos = vec.elements;
	}
	
	viewRot[0] = Math.max(viewRot[0], -deg2rad(90));
	viewRot[0] = Math.min(viewRot[0], deg2rad(90));
	viewRot[1] = normalizeRad(viewRot[1]);
	
	var cx = Math.cos(viewRot[0]),
		sx = Math.sin(viewRot[0]),
		cy = Math.cos(-viewRot[1]),
		sy = Math.sin(-viewRot[1]);
	
	var viewMatrix = Matrix.I(4);
	viewMatrix = viewMatrix.x($M([
		[1,0,0,0],
		[0,1,0,0],
		[0,0,1,0],
		[-viewPos[0],-5,-viewPos[1],1]
	]));
	viewMatrix = viewMatrix.x($M([
		[cy,0,-sy,0],
		[0,1,0,0],
		[sy,0,cy,0],
		[0,0,0,1]
	]));
	viewMatrix = viewMatrix.x($M([
		[1,0,0,0],
		[0,cx,sx,0],
		[0,-sx,cx,0],
		[0,0,0,1]
	]));
	
	var projMatrix = $M([
		[.75,0,0,0],
		[0,1,0,0],
		[0,0,1,1],
		[0,0,0,0]
	]);
	
	// build ground, translate and rotate
	
	var ground = [];
	for(var i = 0; i < coeff.groundTbl.length; ++i) {
		var i1 = coeff.groundTbl[i],
			i2 = coeff.groundTbl[i + 1];
		
		for(var j = 0; j < coeff.groundTbl.length; ++j) {
			var j1 = coeff.groundTbl[j],
				j2 = coeff.groundTbl[j + 1];
			
			var pre = [
				tex2Size[0] / 2,
				tex2Size[1] / 2,
				tex2Size[0] / (coeff.groundTblMax*2),
				tex2Size[1] / (coeff.groundTblMax*2)
			],
			srcVerts1 = [
				pre[0] + j1 * pre[2],
				pre[0] + j2 * pre[2],
				pre[1] - i1 * pre[3],
				pre[1] - i2 * pre[3],
			],
			dstVerts1 = [
				j1 * (coeff.groundRadius / coeff.groundTblMax),
				j2 * (coeff.groundRadius / coeff.groundTblMax),
				i1 * (coeff.groundRadius / coeff.groundTblMax),
				i2 * (coeff.groundRadius / coeff.groundTblMax)
			],
			dstVerts2 = [
				[dstVerts1[0],0,dstVerts1[2]],
				[dstVerts1[0],0,dstVerts1[3]],
				[dstVerts1[1],0,dstVerts1[3]],
				[dstVerts1[1],0,dstVerts1[2]]
			];
			for(var k = 0; k < 4; ++k) {
				dstVerts2[k][3] = 1;
				dstVerts2[k] = $M([dstVerts2[k]]);
				dstVerts2[k] = dstVerts2[k].x(viewMatrix);
				dstVerts2[k] = dstVerts2[k].x(projMatrix);
				dstVerts2[k] = dstVerts2[k].elements[0];
			}
			
			if(dstVerts2[0][2] <= 1
			&& dstVerts2[1][2] <= 1
			&& dstVerts2[2][2] <= 1
			&& dstVerts2[3][2] <= 1)
				continue;
			
			ground.push([
				[
					[srcVerts1[0],srcVerts1[2]],
					[srcVerts1[0],srcVerts1[3]],
					[srcVerts1[1],srcVerts1[3]],
					[srcVerts1[1],srcVerts1[2]]
				],
				dstVerts2,
				1
			]);
		}
	}
	
	// build ceiling, translate and rotate
	
	var ceiling = [];
	for(var i = 0; i < coeff.ceilingTbl.length; ++i) {
		var i1 = coeff.ceilingTbl[i],
			i2 = coeff.ceilingTbl[i + 1];
		
		for(var j = 0; j < coeff.ceilingTbl.length; ++j) {
			var j1 = coeff.ceilingTbl[j],
				j2 = coeff.ceilingTbl[j + 1];
			
			var pre = [
				tex2Size[0] / 2,
				tex2Size[1] / 2,
				tex2Size[0] / (coeff.ceilingTblMax*2),
				tex2Size[1] / (coeff.ceilingTblMax*2)
			],
			srcVerts1 = [
				pre[0] + j1 * pre[2],
				pre[0] + j2 * pre[2],
				pre[1] - i1 * pre[3],
				pre[1] - i2 * pre[3],
			],
			dstVerts1 = [
				j1 * (coeff.groundRadius / coeff.ceilingTblMax),
				j2 * (coeff.groundRadius / coeff.ceilingTblMax),
				i1 * (coeff.groundRadius / coeff.ceilingTblMax),
				i2 * (coeff.groundRadius / coeff.ceilingTblMax)
			],
			dstVerts2 = [
				[dstVerts1[1],coeff.wallHeight,dstVerts1[2]],
				[dstVerts1[1],coeff.wallHeight,dstVerts1[3]],
				[dstVerts1[0],coeff.wallHeight,dstVerts1[3]],
				[dstVerts1[0],coeff.wallHeight,dstVerts1[2]]
			];
			for(var k = 0; k < 4; ++k) {
				dstVerts2[k][3] = 1;
				dstVerts2[k] = $M([dstVerts2[k]]);
				dstVerts2[k] = dstVerts2[k].x(viewMatrix);
				dstVerts2[k] = dstVerts2[k].x(projMatrix);
				dstVerts2[k] = dstVerts2[k].elements[0];
			}
			
			if(dstVerts2[0][2] <= 1
			&& dstVerts2[1][2] <= 1
			&& dstVerts2[2][2] <= 1
			&& dstVerts2[3][2] <= 1)
				continue;
			
			ground.push([
				[
					[srcVerts1[1],srcVerts1[2]],
					[srcVerts1[1],srcVerts1[3]],
					[srcVerts1[0],srcVerts1[3]],
					[srcVerts1[0],srcVerts1[2]]
				],
				dstVerts2,
				2
			]);
		}
	}
	
	// build walls, translate and rotate
	
	var walls4 = [];
	for(var i = 0; i < walls3.length; ++i) {
		var dstVerts1 = [
			[walls3[i][0][0],0,walls3[i][0][1]],
			[walls3[i][0][0],coeff.wallHeight,walls3[i][0][1]],
			[walls3[(i + 1) % walls3.length][0][0],coeff.wallHeight,walls3[(i + 1) % walls3.length][0][1]],
			[walls3[(i + 1) % walls3.length][0][0],0,walls3[(i + 1) % walls3.length][0][1]],
		],
		dstVec = [
			$V(dstVerts1[0]),
			$V(dstVerts1[3]),
			$V(dstVerts1[1]).subtract($V(dstVerts1[0])).x(1/3),
			$V(dstVerts1[2]).subtract($V(dstVerts1[3])).x(1/3)
		],
		dstVerts2 = [
			[
				dstVec[2].x(0).add(dstVec[0]).elements,
				dstVec[2].x(1).add(dstVec[0]).elements,
				dstVec[3].x(1).add(dstVec[1]).elements,
				dstVec[3].x(0).add(dstVec[1]).elements
			],
			[
				dstVec[2].x(1).add(dstVec[0]).elements,
				dstVec[2].x(3).add(dstVec[0]).elements,
				dstVec[3].x(3).add(dstVec[1]).elements,
				dstVec[3].x(1).add(dstVec[1]).elements
			]
		];
		
		var srcCoords = [
			walls3[i][1] * tex1Size[0] / coeff.wallNum,
			((walls3[(i + 1) % walls3.length][1] + coeff.wallNum - 1) % coeff.wallNum + 1) * tex1Size[0] / coeff.wallNum,
			tex1Size[1],
			tex1Size[1] * 2 / 3,
			0
		];
		
		for(var j = 0; j < 2; ++j) {
			for(var k = 0; k < 4; ++k) {
				dstVerts2[j][k][3] = 1;
				dstVerts2[j][k] = $M([dstVerts2[j][k]]);
				dstVerts2[j][k] = dstVerts2[j][k].x(viewMatrix);
				dstVerts2[j][k] = dstVerts2[j][k].x(projMatrix);
				dstVerts2[j][k] = dstVerts2[j][k].elements[0];
			}
			
			if(dstVerts2[j][0][2] <= 1
			&& dstVerts2[j][1][2] <= 1
			&& dstVerts2[j][2][2] <= 1
			&& dstVerts2[j][3][2] <= 1)
				continue;
			
			walls4.push([
				[
					[srcCoords[0], j ? srcCoords[3] : srcCoords[2]],
					[srcCoords[0], j ? srcCoords[4] : srcCoords[3]],
					[srcCoords[1], j ? srcCoords[4] : srcCoords[3]],
					[srcCoords[1], j ? srcCoords[3] : srcCoords[2]]
				],
				dstVerts2[j],
				0
			]);
		}
	}
	
	// z-sort walls
	
	walls4 = walls4.sort(function(a,b){
		za = (a[1][0][3] + a[1][1][3] + a[1][2][3] + a[1][3][3]) / 4;
		zb = (b[1][0][3] + b[1][1][3] + b[1][2][3] + b[1][3][3]) / 4;
		return zb - za;
	});
	
	// merge ground, ceiling and wall quads, split to triangles and segment
	
	var quads = ground.concat(ceiling).concat(walls4);
	for(var i = 0; i < quads.length; ++i) {
		for(var j = 0; j < 4; ++j) {
			quads[i][1][j] = [
				quads[i][1][j][0],
				quads[i][1][j][1],
				quads[i][1][j][2]
			];
		}
	}
	if(qualityMode)
		quads = qualitySegment(quads);
	for(var i = 0; i < quads.length; ++i) {
		var srcMiddle1 = $V(quads[i][0][0]).add($V(quads[i][0][1])).add($V(quads[i][0][2])).add($V(quads[i][0][3])).x(1/4).elements,
			dstMiddle1 = $V(quads[i][1][0]).add($V(quads[i][1][1])).add($V(quads[i][1][2])).add($V(quads[i][1][3])).x(1/4).elements,
			srcVerts1 = [],
			dstVerts1 = [];
		srcVerts1.push([quads[i][0][0], quads[i][0][1], srcMiddle1]);
		srcVerts1.push([quads[i][0][1], quads[i][0][2], srcMiddle1]);
		srcVerts1.push([quads[i][0][2], quads[i][0][3], srcMiddle1]);
		srcVerts1.push([quads[i][0][3], quads[i][0][0], srcMiddle1]);
		dstVerts1.push([quads[i][1][0], quads[i][1][1], dstMiddle1]);
		dstVerts1.push([quads[i][1][1], quads[i][1][2], dstMiddle1]);
		dstVerts1.push([quads[i][1][2], quads[i][1][3], dstMiddle1]);
		dstVerts1.push([quads[i][1][3], quads[i][1][0], dstMiddle1]);
		
		var srcVerts2 = [],
			dstVerts2 = [];
		for(var j = 0; j < dstVerts1.length; ++j) {
			if(dstVerts1[j][0][2] <= coeff.segmentNearDist
			|| dstVerts1[j][1][2] <= coeff.segmentNearDist
			|| dstVerts1[j][2][2] <= coeff.segmentNearDist) {
				var srcMiddle2 = [
						$V(srcVerts1[j][0]).add($V(srcVerts1[j][1])).x(1/2),
						$V(srcVerts1[j][1]).add($V(srcVerts1[j][2])).x(1/2),
						$V(srcVerts1[j][2]).add($V(srcVerts1[j][0])).x(1/2)
					],
					dstMiddle2 = [
						$V(dstVerts1[j][0]).add($V(dstVerts1[j][1])).x(1/2),
						$V(dstVerts1[j][1]).add($V(dstVerts1[j][2])).x(1/2),
						$V(dstVerts1[j][2]).add($V(dstVerts1[j][0])).x(1/2)
					];
				srcVerts2.push([
					srcMiddle2[0].elements,
					srcMiddle2[2].elements,
					srcVerts1[j][0]
				]);
				srcVerts2.push([
					srcMiddle2[1].elements,
					srcMiddle2[0].elements,
					srcVerts1[j][1]
				]);
				srcVerts2.push([
					srcMiddle2[2].elements,
					srcMiddle2[1].elements,
					srcVerts1[j][2]
				]);
				srcVerts2.push([
					srcMiddle2[0].elements,
					srcMiddle2[1].elements,
					srcMiddle2[2].elements
				]);
				dstVerts2.push([
					dstMiddle2[0].elements,
					dstMiddle2[2].elements,
					dstVerts1[j][0]
				]);
				dstVerts2.push([
					dstMiddle2[1].elements,
					dstMiddle2[0].elements,
					dstVerts1[j][1]
				]);
				dstVerts2.push([
					dstMiddle2[2].elements,
					dstMiddle2[1].elements,
					dstVerts1[j][2]
				]);
				dstVerts2.push([
					dstMiddle2[0].elements,
					dstMiddle2[1].elements,
					dstMiddle2[2].elements
				]);
			}
			else {
				srcVerts2.push(srcVerts1[j]);
				dstVerts2.push(dstVerts1[j]);
			}
		}
		
		// clip near
		
		var srcVerts3 = [],
			dstVerts3 = [];
		for(var j = 0; j < dstVerts2.length; ++j) {
			if(dstVerts2[j][0][2] <= 1
			&& dstVerts2[j][1][2] <= 1
			&& dstVerts2[j][2][2] <= 1)
				continue;
			
			if(dstVerts2[j][0][2] <= 1
			|| dstVerts2[j][1][2] <= 1
			|| dstVerts2[j][2][2] <= 1) {
				var mode,
					srcClip1,
					dstClip1;
				if(dstVerts2[j][0][2] <= 1
				&& dstVerts2[j][1][2] <= 1) {
					mode = 0;
					srcClip1 = [srcVerts2[j][0], srcVerts2[j][1], srcVerts2[j][2]];
					dstClip1 = [dstVerts2[j][0], dstVerts2[j][1], dstVerts2[j][2]];
				}
				else if(dstVerts2[j][1][2] <= 1
				&& dstVerts2[j][2][2] <= 1) {
					mode = 0;
					srcClip1 = [srcVerts2[j][1], srcVerts2[j][2], srcVerts2[j][0]];
					dstClip1 = [dstVerts2[j][1], dstVerts2[j][2], dstVerts2[j][0]];
				}
				else if(dstVerts2[j][2][2] <= 1
				&& dstVerts2[j][0][2] <= 1) {
					mode = 0;
					srcClip1 = [srcVerts2[j][2], srcVerts2[j][0], srcVerts2[j][1]];
					dstClip1 = [dstVerts2[j][2], dstVerts2[j][0], dstVerts2[j][1]];
				}
				else if(dstVerts2[j][0][2] <= 1) {
					mode = 1;
					srcClip1 = [srcVerts2[j][1], srcVerts2[j][2], srcVerts2[j][0]];
					dstClip1 = [dstVerts2[j][1], dstVerts2[j][2], dstVerts2[j][0]];
				}
				else if(dstVerts2[j][1][2] <= 1) {
					mode = 1;
					srcClip1 = [srcVerts2[j][2], srcVerts2[j][0], srcVerts2[j][1]];
					dstClip1 = [dstVerts2[j][2], dstVerts2[j][0], dstVerts2[j][1]];
				}
				else if(dstVerts2[j][2][2] <= 1) {
					mode = 1;
					srcClip1 = [srcVerts2[j][0], srcVerts2[j][1], srcVerts2[j][2]];
					dstClip1 = [dstVerts2[j][0], dstVerts2[j][1], dstVerts2[j][2]];
				}
				
				try {
					var srcVec = [
						$V(srcClip1[0]).subtract($V(srcClip1[2])),
						$V(srcClip1[1]).subtract($V(srcClip1[2])),
						$V(srcClip1[2])
					],
					dstVec = [
						Plane.XY.translate(Vector.k).intersectionWith($L($V(dstClip1[2]),$V(dstClip1[0]).subtract($V(dstClip1[2])))),
						Plane.XY.translate(Vector.k).intersectionWith($L($V(dstClip1[2]),$V(dstClip1[1]).subtract($V(dstClip1[2]))))
					],
					dstClip2 = [
						dstVec[0].elements,
						dstVec[1].elements,
						dstClip1[2]
					],
					dist = [
						Math.min($V(dstClip2[0]).distanceFrom($V(dstClip2[2])) / $V(dstClip1[0]).distanceFrom($V(dstClip1[2])),1),
						Math.min($V(dstClip2[1]).distanceFrom($V(dstClip2[2])) / $V(dstClip1[1]).distanceFrom($V(dstClip1[2])),1)
					],
					srcClip2 = [
						srcVec[0].x(dist[0]).add(srcVec[2]).elements,
						srcVec[1].x(dist[1]).add(srcVec[2]).elements,
						srcClip1[2]
					];
					if(!mode) {
						srcVerts3.push(srcClip2);
						dstVerts3.push(dstClip2);
					}
					else {
						var srcMiddle3 = $V(srcClip2[0]).add($V(srcClip2[1])).x(1/2).elements,
							dstMiddle3 = $V(dstClip2[0]).add($V(dstClip2[1])).x(1/2).elements;
						srcVerts3.push([
							srcClip2[0],
							srcClip1[0],
							srcMiddle3
						]);
						srcVerts3.push([
							srcClip1[1],
							srcClip2[1],
							srcMiddle3
						]);
						srcVerts3.push([
							srcClip1[0],
							srcClip1[1],
							srcMiddle3
						]);
						dstVerts3.push([
							dstClip2[0],
							dstClip1[0],
							dstMiddle3
						]);
						dstVerts3.push([
							dstClip1[1],
							dstClip2[1],
							dstMiddle3
						]);
						dstVerts3.push([
							dstClip1[0],
							dstClip1[1],
							dstMiddle3
						]);
					}
				}
				catch(e) { }
			}
			else {
				srcVerts3.push(srcVerts2[j]);
				dstVerts3.push(dstVerts2[j]);
			}
		}
		
		// convert triangles to viewport coordinates and draw to buffer
		// assume near clipped
		// cull viewport and backface
		
		for(var j = 0; j < dstVerts3.length; ++j) {
			var dstCoords = [];
			for(var k = 0; k < 3; ++k) {
				var depth = Math.max(dstVerts3[j][k][2], 1);
				dstCoords[k] = [
					outSize[0]/2+dstVerts3[j][k][0]/depth*outSize[0]/2,
					outSize[1]/2-dstVerts3[j][k][1]/depth*outSize[1]/2
				];
			}
			
			if(dstCoords[0][0] <= 0
			&& dstCoords[1][0] <= 0
			&& dstCoords[2][0] <= 0)
				continue;
			
			if(dstCoords[0][0] > outSize[0]
			&& dstCoords[1][0] > outSize[0]
			&& dstCoords[2][0] > outSize[0])
				continue;
			
			if(dstCoords[0][1] <= 0
			&& dstCoords[1][1] <= 0
			&& dstCoords[2][1] <= 0)
				continue;
			
			if(dstCoords[0][1] > outSize[1]
			&& dstCoords[1][1] > outSize[1]
			&& dstCoords[2][1] > outSize[1])
				continue;
			
			var normal = $V([dstCoords[2][0]-dstCoords[0][0],dstCoords[2][1]-dstCoords[0][1],0]).cross($V([dstCoords[1][0]-dstCoords[0][0],dstCoords[1][1]-dstCoords[0][1],0]));
			if(normal.elements[2] > 0)
				continue;
			
			transformTriangle(texImg2[quads[i][2]], srcVerts3[j], buf, dstCoords, true);
		}
	}
	
	// draw compass to buffer
	
	for(var i = 0; i < links3.length; ++i) {
		var heading = normalizeRad(coeff.compassTolerance - links3[i][2] - viewRot[1]),
			linkCoords,
			linkSize;
		
		if(heading < (coeff.compassTolerance*2)) {
			linkSize = outSize[1] / coeff.compassSizeQuota;
			linkCoords = [
				heading / (coeff.compassTolerance*2) * outSize[0],
				outSize[1] - (linkSize*2),
				1
			];
		}
		else {
			linkSize = outSize[1] / (coeff.compassSizeQuota << 1);
			linkCoords = [
				normalizeRad(-heading) / normalizeRad(-coeff.compassTolerance*2) * outSize[0],
				outSize[1] - linkSize*3,
				-1
			];
		}

		var dist = Math.ceil(($V(loadPos).distanceFrom($V(links3[i][1])) - $V(loadPos).distanceFrom(Vector.Zero(2))) / loadDist);
		
		buf.save();
		buf.translate(linkCoords[0],linkCoords[1]);
		
		buf.fillStyle = (heading >= (coeff.compassTolerance*2) || dist > 0) ? '#0f0' : '#fff';
		buf.strokeStyle = '#000';
		buf.lineWidth = 1;
		buf.beginPath();
		buf.moveTo(0,(-linkSize*2)*linkCoords[2]);
		buf.lineTo(linkSize,0);
		buf.lineTo(-linkSize,0);
		buf.closePath();
		buf.fill();
		buf.stroke();
		
		if(heading < (coeff.compassTolerance*2) && dist > 0) {
			buf.fillStyle = '#fff';
			buf.font = 'bold ' + (linkSize*3/4) + 'px sans-serif';
			buf.textAlign = 'center';
			buf.textBaseline = 'middle';
			buf.fillText(dist,0,(-linkSize/2)*linkCoords[2]);
		}
		
		buf.restore();
	}
	
	// swap buffer
	
	out.drawImage(bufImg,0,0);
	
	if(fade) {
		$('#outImg').finish();
		$('#outImg').fadeTo(0,.5);
		$('#outImg').fadeTo(500,1);
		fade = false;
	}
	
	// repeat after concurrent event
	
	isUpdating = false;
	if(requiresUpdate)
		setTimeout(update, 1);
}

// key and event handlers

var isMoving = false;
function move(x,z) {
	isMoving = true;
	var vec = $V([x,z]).rotate(-viewRot[1], [0,0]);
	
	viewPos = $V(viewPos).add(vec.x(isLoading ? coeff.moveSpeedLoading : coeff.moveSpeed)).elements;
	loadDistPos = $V(loadDistPos).add(vec.x(isLoading ? coeff.moveSpeedLoading : coeff.moveSpeed)).elements;
	loadPos = $V(viewPos).add(vec.x(loadDist)).elements;
	
	setTimeout(load, 1);
}

var pressed = {},
	pressedOnce = {},
	pressedTimer = false,
	skipCtr = 0;
function handlePressed() {
	isMoving = false;
	var isPressed = false;
	for(var key in pressed) {
		if(pressed[key])
			pressedOnce[key] = true;
	}
	for(var key in pressedOnce) {
		if(pressedOnce[key]) {
			isPressed = true;
			switch(parseInt(key)) {
			case 87: // w
				move(0,1);
			break;
			case 65: // a
				move(-1,0);
			break;
			case 83: // s
				move(0,-1);
			break;
			case 68: // d
				move(1,0);
			break;
			case 37: // left
				viewRot[1] -= coeff.viewYawStep;
			break;
			case 38: // up
				viewRot[0] -= coeff.viewPitchStep;
			break;
			case 39: // right
				viewRot[1] += coeff.viewYawStep;
			break;
			case 40: // down
				viewRot[0] += coeff.viewPitchStep;
			break;
			}
		}
	}
	
	if(!isMoving) {
		loadDistPos = [0,0];
	}
	loadDist = $V(loadDistPos).distanceFrom(Vector.Zero(2)) / coeff.loadDistQuota;
	loadDist = Math.max(loadDist,1);
	loadDist = Math.min(loadDist,coeff.maxLoadDist);
	
	pressedOnce = [];
	if(isPressed){
		if(!isLoading)
			skipCtr = 0;
		if(!(skipCtr++ % coeff.keyIntervalLoadingMult))
			setTimeout(update, 1);
		setTimeout(handlePressed, coeff.keyInterval);
	}
	else {
		pressedTimer = false;
	}
}

keydownHandler = function(key) {
	switch(key) {
	case 87: // w
	case 65: // a
	case 83: // s
	case 68: // d
	case 37: // left
	case 38: // up
	case 39: // right
	case 40: // down
		pressed[key] = true;
		pressedOnce[key] = true;
		if(!pressedTimer) {
			pressedTimer = true;
			setTimeout(handlePressed, 1);
		}
	}
}
$(window).keydown(function(e) {
	keydownHandler(e.which);
});

keyupHandler = function(key) {
	switch(key) {
	case 87: // w
	case 65: // a
	case 83: // s
	case 68: // d
	case 37: // left
	case 38: // up
	case 39: // right
	case 40: // down
		pressed[key] = false;
	}
}
$(window).keyup(function(e) {
	keyupHandler(e.which);
});

$(window).resize(function() {
	setTimeout(update, 1);
});

$(window).error(function() {
	if(!abortOnFail) {
		$('#fail_gen').show();
		$('#outImg').hide();
	}
});

// run!

setTimeout(load, 1);

});
</script>
</body>
</html>
