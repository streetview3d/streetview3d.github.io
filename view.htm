<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<script type="text/javascript">alert = function() {};</script>
<script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDtlKIl02bk1ebAl4zYhC3gx5l5BkzxSSQ&sensor=false"></script>
<script type="text/javascript" src="jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="pako_inflate.min.js"></script>
<script type="text/javascript" src="sylvester.js"></script>
</head>
<body style="background-color:#000;margin:0px;padding:0px;">

<table style="width:100%; height:100%; color:#fff; font-family: sans-serif; font-size: smaller;">
<tr><td style="text-align:center; font-weight:bold;">Move: W A S D, Look: Cursor keys&nbsp;&nbsp;&nbsp;<a href="javascript:void(0)" style="color:#ccf;" onclick="if($('#ctrlCont').is(':visible')) {$('#ctrlCont').hide(); $(this).text('Show buttons');} else {$('#ctrlCont').show(); $(this).text('Hide buttons');} setTimeout(update, 1);">Show buttons</a>&nbsp;&nbsp;&nbsp;<a href="javascript:void(0)" style="color:#ccf;" onclick="if(qualityMode) {qualityMode = false; $(this).text('HQ OFF');} else {qualityMode = true; $(this).text('HQ ON');} forceLoad = true; setTimeout(load, 1);">HQ OFF</a></td></tr>
<tr><td id="outCont" style="text-align:center; height:100%;">
<div id="fail_js">You have to enable Javascript in your browser!</div>
<div id="fail_data" style="display:none;">Sorry, no Street View data found for this address!</div>
<div id="fail_query" style="display:none;">Specify the address or location in the browser's address bar, e.g. <a href="https://streetview3d.github.io/view.htm?loc=39.296386,-76.613949&dir=s" style="color:#ccf;">https://streetview3d.github.io/view.htm?loc=39.296386,-76.613949&dir=s</a></div>
<div id="fail_gen" style="display:none;">Something went wrong...</div>
<div id="fail_key" style="display:none;">Sorry, it seems that Google has revoked my API Key...</div>
<canvas id="outImg">You have to look for a browser, which supports HTML5!</canvas>
</td></tr>
<tr><td><div id="ctrlCont" style="text-align:center; font-weight:bold; white-space:nowrap; display:none;">
Move:
<input type="button" value="<" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(65)" onmouseup="keyupHandler(65)" onmouseout="keyupHandler(65)" />
&nbsp;
<input type="button" value="/\" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(87)" onmouseup="keyupHandler(87)" onmouseout="keyupHandler(87)" />
&nbsp;
<input type="button" value="\/" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(83)" onmouseup="keyupHandler(83)" onmouseout="keyupHandler(83)" />
&nbsp;
<input type="button" value=">" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(68)" onmouseup="keyupHandler(68)" onmouseout="keyupHandler(68)" />
&nbsp;
Look:
<input type="button" value="<" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(37)" onmouseup="keyupHandler(37)" onmouseout="keyupHandler(37)" />
&nbsp;
<input type="button" value="/\" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(40)" onmouseup="keyupHandler(40)" onmouseout="keyupHandler(40)" />
&nbsp;
<input type="button" value="\/" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(38)" onmouseup="keyupHandler(38)" onmouseout="keyupHandler(38)" />
&nbsp;
<input type="button" value=">" class="btn" style="min-width:2em; min-height:2em; width:2em; height:2em;" onmousedown="keydownHandler(39)" onmouseup="keyupHandler(39)" onmouseout="keyupHandler(39)" />
</div></td></tr>
</table>

<script type="text/javascript">

// global accessible functions and initialization

var load = function() {},
	update = function() {},
	keydownHandler = function() {},
	keyupHandler = function() {},
	qualityMode = false,
	forceLoad = false;
$(function() {

var failed = false,
	abortOnFail = false;
$('#fail_js').hide();

jQuery.fx.interval = Math.max(jQuery.fx.interval, 50);

// convert polar coordinates to equirectangular projection

function radialCoord(center, angle, radius, invertY) {
	return [
		center[0] + Math.sin(angle) * radius,
		center[1] + Math.cos(angle) * radius * ((invertY) ? -1 : 1)
	];
}

// normalize radian to the range from 0 to 2*pi

function normalizeRad(radian) {
	return ((radian) % (Math.PI*2) + (Math.PI*2)) % (Math.PI*2);
}

// convert degree to radian

function deg2rad(degree) {
	return normalizeRad(degree * (Math.PI/180));
}

// copy triangle from one buffer to another and apply affine transformation
// coordinates are extrapolated to remove gaps between polygons

function transformTriangle(srcImg, dstCtx, vert1, wireframe) {
	dstCtx.save();

	var coords = [];
	for(var i = 0; i < 2; ++i) {
		var vert2 = [
				vert1[i][1].subtract(vert1[i][0]),
				vert1[i][2].subtract(vert1[i][1]),
				vert1[i][0].subtract(vert1[i][2])
			],
			pre1 = [
				vert1[i][1].distanceFrom(vert1[i][2]),
				vert1[i][2].distanceFrom(vert1[i][0]),
				vert1[i][0].distanceFrom(vert1[i][1]),
				Math.cos((Math.PI/2) - vert2[0].angleFrom(vert2[2].x(-1)) / 2),
				Math.cos((Math.PI/2) - vert2[1].angleFrom(vert2[0].x(-1)) / 2),
				Math.cos((Math.PI/2) - vert2[2].angleFrom(vert2[1].x(-1)) / 2)
			],
			center = vert1[i][0].x(pre1[0]).add(vert1[i][1].x(pre1[1])).add(vert1[i][2].x(pre1[2])).x(1 / (pre1[0] + pre1[1] + pre1[2])),
			pre2 = [
				vert1[i][0].subtract(center),
				vert1[i][1].subtract(center),
				vert1[i][2].subtract(center),
				vert1[i][0].distanceFrom(center),
				vert1[i][1].distanceFrom(center),
				vert1[i][2].distanceFrom(center)
			];
		
		coords[i] = [];
		for(var j = 0; j < 3; ++j) {
			vert1[i][j] = pre2[j].x((pre2[j + 3] + Math.min(((i) ? 1/2 : 1/4) / pre1[j + 3], ((i) ? 2 : 2))) / pre2[j + 3]).add(center);
			coords[i][j] = vert1[i][j].elements;
		}
	}
	for(var j = 0; j < 3; ++j) {
		coords[0][j][0] = Math.max(coords[0][j][0], 0);
		coords[0][j][0] = Math.min(coords[0][j][0], srcImg.width);
		coords[0][j][1] = Math.max(coords[0][j][1], 0);
		coords[0][j][1] = Math.min(coords[0][j][1], srcImg.height);
	}
	
	dstCtx.beginPath();
	dstCtx.moveTo(coords[1][0][0], coords[1][0][1]);
	dstCtx.lineTo(coords[1][1][0], coords[1][1][1]);
	dstCtx.lineTo(coords[1][2][0], coords[1][2][1]);
	dstCtx.closePath();
	dstCtx.clip();
	
	var x0 = coords[1][0][0],
		y0 = coords[1][0][1],
		x1 = coords[1][1][0] - x0,
		y1 = coords[1][1][1] - y0,
		x2 = coords[1][2][0] - x0,
		y2 = coords[1][2][1] - y0,
		u0 = coords[0][0][0],
		v0 = coords[0][0][1],
		u1 = coords[0][1][0] - u0,
		v1 = coords[0][1][1] - v0,
		u2 = coords[0][2][0] - u0,
		v2 = coords[0][2][1] - v0;
	
	var denom = (u1*v2 - u2*v1);
	if(denom != 0) {
		var det = 1 / denom,
			a = (v2*x1 - v1*x2) * det,
			b = (v2*y1 - v1*y2) * det,
			c = (u1*x2 - u2*x1) * det,
			d = (u1*y2 - u2*y1) * det,
			e = x0 - a*u0 - c*v0,
			f = y0 - b*u0 - d*v0;
		
		dstCtx.transform(a, b, c, d, e, f);
		
		var bx0 = Math.max(Math.floor(Math.min(coords[0][0][0], coords[0][1][0], coords[0][2][0])), 0),
			by0 = Math.max(Math.floor(Math.min(coords[0][0][1], coords[0][1][1], coords[0][2][1])), 0),
			bx1 = Math.min(Math.ceil(Math.max(coords[0][0][0], coords[0][1][0], coords[0][2][0])), srcImg.width),
			by1 = Math.min(Math.ceil(Math.max(coords[0][0][1], coords[0][1][1], coords[0][2][1])), srcImg.height);
		dstCtx.drawImage(srcImg, bx0, by0, bx1 - bx0, by1 - by0, bx0, by0, bx1 - bx0, by1 - by0);
	}
	
	dstCtx.restore();
	
	/*if(wireframe) {
		dstCtx.strokeStyle = '#fff';
		dstCtx.lineWidth = 1;
		dstCtx.beginPath();
		dstCtx.moveTo(coords[1][0][0],coords[1][0][1]);
		dstCtx.lineTo(coords[1][1][0],coords[1][1][1]);
		dstCtx.lineTo(coords[1][2][0],coords[1][2][1]);
		dstCtx.closePath();
		dstCtx.stroke();
	}*/
}

// same, but segment quad first

function transformQuad1(srcCtx, dstCtx, quad, center) {
	if(qualityMode) {
		var quads = qualitySegment([quad]);
		for(var i = 0; i < 4; ++i)
			transformQuad2(srcCtx, dstCtx, quads[i], (center && i < 2));
	}
	else {
		transformQuad2(srcCtx, dstCtx, quad, center);
	}
}

function transformQuad2(srcCtx, dstCtx, quad, center) {
	var srcMiddle = quad[0][0].add(quad[0][1]).add(quad[0][2]).add(quad[0][3]).x(1/4),
		dstMiddle = quad[1][0].add(quad[1][1]).add(quad[1][2]).add(quad[1][3]).x(1/4);
	transformTriangle(srcCtx, dstCtx, [[quad[0][0], quad[0][1], srcMiddle], [quad[1][0], quad[1][1], dstMiddle]], false);
	transformTriangle(srcCtx, dstCtx, [[quad[0][1], quad[0][2], srcMiddle], [quad[1][1], quad[1][2], dstMiddle]], false);
	transformTriangle(srcCtx, dstCtx, [[quad[0][2], quad[0][3], srcMiddle], [quad[1][2], quad[1][3], dstMiddle]], false);
	if(!center)
		transformTriangle(srcCtx, dstCtx, [[quad[0][3], quad[0][0], srcMiddle], [quad[1][3], quad[1][0], dstMiddle]], false);
}

// segment quads for quality mode

function qualitySegment(quads1) {
	var quads2 = [];
	
	for(var i = 0; i < quads1.length; ++i) {
		var srcQuad = quads1[i][0],
			srcPoint = [
				[
					srcQuad[0],
					srcQuad[0].add(srcQuad[3]).x(1/2),
					srcQuad[3],
				],
				[
					srcQuad[0].add(srcQuad[1]).x(1/2),
					null,
					srcQuad[3].add(srcQuad[2]).x(1/2)
				],
				[
					srcQuad[1],
					srcQuad[1].add(srcQuad[2]).x(1/2),
					srcQuad[2],
				]
			],
			dstQuad = quads1[i][1],
			dstPoint = [
				[
					dstQuad[0],
					dstQuad[0].add(dstQuad[3]).x(1/2),
					dstQuad[3],
				],
				[
					dstQuad[0].add(dstQuad[1]).x(1/2),
					null,
					dstQuad[3].add(dstQuad[2]).x(1/2)
				],
				[
					dstQuad[1],
					dstQuad[1].add(dstQuad[2]).x(1/2),
					dstQuad[2],
				]
			];
			srcPoint[1][1] = srcPoint[1][0].add(srcPoint[1][2]).x(1/2);
			dstPoint[1][1] = dstPoint[1][0].add(dstPoint[1][2]).x(1/2);
		quads2.push([
			[srcPoint[0][0], srcPoint[1][0], srcPoint[1][1], srcPoint[0][1]],
			[dstPoint[0][0], dstPoint[1][0], dstPoint[1][1], dstPoint[0][1]],
			quads1[i][2]
		]);
		quads2.push([
			[srcPoint[0][1], srcPoint[1][1], srcPoint[1][2], srcPoint[0][2]],
			[dstPoint[0][1], dstPoint[1][1], dstPoint[1][2], dstPoint[0][2]],
			quads1[i][2]
		]);
		quads2.push([
			[srcPoint[1][0], srcPoint[2][0], srcPoint[2][1], srcPoint[1][1]],
			[dstPoint[1][0], dstPoint[2][0], dstPoint[2][1], dstPoint[1][1]],
			quads1[i][2]
		]);
		quads2.push([
			[srcPoint[1][1], srcPoint[2][1], srcPoint[2][2], srcPoint[1][2]],
			[dstPoint[1][1], dstPoint[2][1], dstPoint[2][2], dstPoint[1][2]],
			quads1[i][2]
		]);
	}
	
	return quads2;
}

// floating point number decoder

function Bytes2Float32(bytes) {
	var sign = (bytes & 0x80000000) ? -1 : 1,
		exponent = ((bytes >> 23) & 0xFF) - 127,
		significand = (bytes & ~(-1 << 23));
	
	if(exponent == 128)
		return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);
	
	if(exponent == -127) {
		if(significand == 0) return sign * 0.0;
		exponent = -126;
		significand /= (1 << 22);
	} else significand = (significand | (1 << 23)) / (1 << 23);
	
	return sign * significand * Math.pow(2, exponent);
}

// query parameter extraction

function getParam(param) {
	regex = new RegExp('[\\?&]' + param + '=([^&#]*)'),
		result = regex.exec(location.search);
	return (result == null) ? '' : decodeURIComponent(result[1].replace(/\+/g, ' '));
}

// global coeffs

var coeff = {
	wallNum: 32,
	wallHeight: 80,
	camHeight: 2.75,
	groundRadius: 80,
	minWallRadius: 10,
	minWallRadiusThreshold: 20,
	maxWallRadius: 70,
	maxWallRadius2: 100,
	minLinkRadius: 20,
	maxLinkRadius: 80,
	skipLinkDist: 100,
	removeTreeDist: 20,
	removeTreeQuota: 2,
	mergeWallsDist: 40,
	mergeWallsTolerance: 5,
	segmentNearDist: 20,
	loadWallPitchNum: 4,
	loadGroundPitchNum: 4,
	loadGroundYawStart: 4,
	loadGroundYawStartQuality: 8,
	groundTblMax: 8,
	groundTbl: [
		-8,
		-3,
		-1,
		0,
		1,
		3,
		8
	],
	ceilingTblMax: 8,
	ceilingTbl: [
		-8,
		-3,
		0,
		3,
		8
	],
	skipTolerance: deg2rad(45),
	loadTolerance: deg2rad(45),
	compassTolerance: deg2rad(135/2),
	compassSizeQuota: 32,
	loadDistQuota: 2, 
	maxLoadDist: 20,
	loadDistSideQuota: 4,
	moveSpeed: 2.5,
	viewYawStep: deg2rad(360/128),
	viewYawStepAccel: deg2rad(360/32),
	viewPitchStep: deg2rad(90/8),
	viewHeight: 5,
	keyInterval: 100
};

// constant query parameters

var zoomLevel = 3,
	panoSize = [416 << zoomLevel,(416 << zoomLevel) >> 1],
	tileSize = [512, 512],
	tex1Size = [panoSize[0],panoSize[1] >> 1],
	tex2Size = [panoSize[0] >> 1,panoSize[0] >> 1];

// global state

var viewPos = $V([.07,.03]),
	loadPos = viewPos,
	loadDistPos = Vector.Zero(2),
	loadDist = 1,
	viewRot = [0,0],
	latLng = null,
	panoId = null,
	centerHeading = null,
	fade = false;

// loaded resources

var texImg2 = null,
	tex2 = null,
	walls3 = null,
	links3 = [];

// panorama load routine

var initialLoading = true,
	isLoading = false;

load = function() {

	// handle concurrent event
	
	if(isLoading)
		return;
	isLoading = true;
	
	// check link proximity and direction
	
	var linkPos = Vector.Zero(2),
		previousCenterHeading = centerHeading,
		nearestAngle = coeff.loadTolerance;
	for(var i = 0; i < links3.length; ++i) {
		var posLinkDist = loadPos.distanceFrom(links3[i][1]),
			posCenterDist = loadPos.distanceFrom(Vector.Zero(2)),
			moveAngle = loadPos.subtract(viewPos).angleFrom(links3[i][1]);
		if(posLinkDist < posCenterDist
		&& nearestAngle > moveAngle) {
			nearestAngle = moveAngle;
			panoId = links3[i][0];
			linkPos = links3[i][1];
		}
	}
	
	if(!forceLoad && !initialLoading && nearestAngle == coeff.loadTolerance) {
		isLoading = false;
		return;
	}
	forceLoad = false;
	
	// fade output image
	
	$('#outImg').finish();
	$('#outImg').fadeTo(0,.5);
	
	// declare temporary buffers
	
	var texImg1 = [
		document.createElement('canvas'),
		document.createElement('canvas'),
		document.createElement('canvas')
	];
	
	texImg1[0].width = tex1Size[0];
	texImg1[0].height = tex1Size[1];
	texImg1[1].width = tex2Size[0];
	texImg1[1].height = tex2Size[1];
	texImg1[2].width = tex2Size[0];
	texImg1[2].height = tex2Size[1];
	
	var tex1 = [
		texImg1[0].getContext('2d'),
		texImg1[1].getContext('2d'),
		texImg1[2].getContext('2d')
	];
	
	var panoImg,
		walls1,
		links1 = [],
		links2 = [];
	
	// manage and serialize asynchronous calls
	
	var stepCtr = -1;
	var tryCtr1 = 0;
	var retryTimer = null;
	var failTimer = null;
	function next(tryCtr3) {
		if(tryCtr1 == tryCtr3) {
			clearTimeout(retryTimer);
			clearTimeout(failTimer);
			if(!failed) {
				$('#fail_key').hide();
				$('#outImg').show();
			}
		
			if(stepCtr + 1 < steps.length) {
				retryTimer = setTimeout(function() {
					tryCtr1++;
					setTimeout(steps[stepCtr], 1);
				}, 2000);
				failTimer = setTimeout(function() {
					if(!failed) {
						$('#fail_key').show();
						$('#outImg').hide();
					}
				}, 4000);
			
				setTimeout(steps[++stepCtr], 1);
			}
		}
	}
	var steps = [
		
		// load panoId for address or use an explicit one
		
		function() {
			var tryCtr2 = tryCtr1;
			
			var query = getParam('loc');
			if(!query.length) {
				$('#fail_query').show();
				$('#outImg').hide();
				abortOnFail = true;
				throw null;
			}
			
			if(initialLoading) {
				new google.maps.Geocoder().geocode(
					{
						address: query
					},
					function(data) {
						try {
							latLng = data[0].geometry.location;
						}
						catch(e) {
							$('#fail_data').show();
							$('#fail_query').show();
							$('#outImg').hide();
							abortOnFail = true;
							throw e;
						}
						
						next(tryCtr2);
					}
				);
			}
			else {
				next(tryCtr2);
			}
		},
		
		// load panorama details
		
		function() {
			var tryCtr2 = tryCtr1;
			
			var success = function(data) {
				try {
					panoId = data.location.pano;
					centerHeading = deg2rad(data.tiles.centerHeading);
				}
				catch(e) {
					$('#fail_data').show();
					$('#fail_query').show();
					$('#outImg').hide();
					abortOnFail = true;
					throw e;
				}
				
				next(tryCtr2);
			}
			
			if(initialLoading) {
				new google.maps.StreetViewService().getPanoramaByLocation(
					latLng,
					50,
					success
				);
			}
			else {
				new google.maps.StreetViewService().getPanoramaById(
					panoId,
					success
				);
			}
		},
		
		// load depth map
		
		function() {
			var tryCtr2 = tryCtr1;
			
			$.ajax({
				url: 'https://maps.google.com/cbk?output=json&dm=1&pm=1&ph=1&panoid='+panoId,
				dataType: 'jsonp',
				success: function(data) {
					latLng = new google.maps.LatLng(data.Location.original_lat, data.Location.original_lng);
					
					for(var i = 0; i < data.Links.length; ++i) {
						links1[i] = [
							data.Links[i].panoId,
							latLng,
							normalizeRad(deg2rad(parseFloat(data.Links[i].yawDeg)) - centerHeading),
							Vector.Zero(2)
						];
					}
					
					var depthMap1 = data.model.depth_map;
					
					depthMap1 = depthMap1.replace(/-/g,'+');
					depthMap1 = depthMap1.replace(/_/g,'/');
					depthMap1 = atob(depthMap1);
					depthMap1 = pako.inflate(depthMap1);
					
					var planeCount = (depthMap1[2] << 8) | depthMap1[1],
						width = (depthMap1[4] << 8) | depthMap1[3],
						height = (depthMap1[6] << 8) | depthMap1[5],
						offset = (depthMap1[8] << 8) | depthMap1[7];
					
					var depthMap2 = [];
					for(var i = 0; i < planeCount; ++i) {
						depthMap2[i] = [];
						for(var j = 0; j < 4; ++j) {
							var pos = width * height + offset + i * 16 + j * 4;
							depthMap2[i][j] = Bytes2Float32((depthMap1[pos+3] << 24) | (depthMap1[pos+2] << 16) | (depthMap1[pos+1] << 8) | depthMap1[pos]);
						}
					}
					
					var depthMap4 = [];
					for(var yaw = 0; yaw < coeff.wallNum; ++yaw) {
						var depthMap3 = [];
						for(var pitch = 0; pitch < 3; ++pitch) {
							var x = yaw * width / coeff.wallNum,
								y = height / 2 - pitch * height / coeff.wallNum,
								index = depthMap1[offset + y * width + x],
								depth = coeff.maxWallRadius2;
							if(index > 0) {
								var phi = (width - x - 1) / (width - 1) * 2 * (Math.PI) + (Math.PI/2),
									theta = (height - y - 1) / (height - 1) * (Math.PI),
									v = [
										Math.sin(theta) * Math.cos(phi),
										Math.sin(theta) * Math.sin(phi),
										Math.cos(theta)
									],
									plane = depthMap2[index],
									t = plane[3] / (v[0]*plane[0] + v[1]*plane[1] + v[2]*plane[2]);
								v[0] *= t;
								v[1] *= t;
								v[2] *= t;
								depth = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
								if(depth < coeff.minWallRadiusThreshold)
									depth = coeff.minWallRadiusThreshold - (coeff.minWallRadiusThreshold - depth) / 2
								depth = Math.max(depth, coeff.minWallRadius);
								depth = Math.min(depth, coeff.maxWallRadius2);
							}
							depthMap3[pitch] = depth;
						}
						
						depthMap4[yaw] = (depthMap3[0]*4 + depthMap3[1]*2 + depthMap3[2]) / 7;
						depthMap4[yaw] = Math.min(depthMap4[yaw], coeff.maxWallRadius);
					}
					
					var depthMap5 = [];
					for(var yaw = 0; yaw < coeff.wallNum; ++yaw) {
						var middle = (depthMap4[(yaw + coeff.wallNum - 1) % coeff.wallNum] + depthMap4[(yaw + 1) % coeff.wallNum]) / 2,
							amount = Math.abs(depthMap4[yaw] - middle);
						if(amount >= coeff.removeTreeDist
						&& Math.abs(depthMap4[(yaw + coeff.wallNum - 1) % coeff.wallNum] - depthMap4[(yaw + 1) % coeff.wallNum]) <= amount / coeff.removeTreeQuota) {
							depthMap5[yaw] = middle;
						}
						else {
							depthMap5[yaw] = depthMap4[yaw];
						}
					}
					
					walls1 = depthMap5;
					
					next(tryCtr2);
				}
			});
		},
		
		// load panorama bitmap and links
		
		function() {
			var tryCtr2 = tryCtr1,
				nextCtr = 1;
			
			panoImg = document.createElement('canvas');
			panoImg.width = panoSize[0];
			panoImg.height = panoSize[1];
			
			for(var y1 = 0, y2 = 0; y2 < panoSize[1]; ++y1, y2 += tileSize[1]) {
				for(var x1 = 0, x2 = 0; x2 < panoSize[0]; ++x1, x2 += tileSize[0]) {
					nextCtr++;
					(function(x1,x2,y1,y2) {
						var tileImg = new Image();
						tileImg.onload = function() {
							panoImg.getContext('2d').drawImage(tileImg,x2,y2);
							
							if(!--nextCtr)
								next(tryCtr2);
						}
						tileImg.src = 'https://cbk0.google.com/cbk?output=tile&zoom='+zoomLevel+'&x='+x1+'&y='+y1+'&panoid='+panoId;
					})(x1,x2,y1,y2);
				}
			}
			
			// load links
			
			for(var i = 0; i < links1.length; ++i) {
				nextCtr++;
				function nextLink(link) {
					$.ajax({
						url: 'https://maps.google.com/cbk?output=json&dm=1&pm=1&ph=1&panoid='+link[0],
						dataType: 'jsonp',
						success: function(data) {
							var dist1 = google.maps.geometry.spherical.computeDistanceBetween(link[1], new google.maps.LatLng(data.Location.original_lat, data.Location.original_lng)),
								vec = $V([0,dist1]).rotate(-link[2], Vector.Zero(2));
							
							link[3] = link[3].add(vec);
							
							var dist2 = link[3].distanceFrom(Vector.Zero(2));
							if(dist2 < coeff.skipLinkDist && data.Links.length == 2) {
								for(var i = 0; i < data.Links.length; ++i) {
									var heading = normalizeRad(deg2rad(parseFloat(data.Links[i].yawDeg)) - centerHeading);
									
									if(Math.abs(link[2] - heading) < coeff.skipTolerance
									|| Math.abs(link[2] - heading) > normalizeRad(-coeff.skipTolerance)) {
										link = [
											data.Links[i].panoId,
											new google.maps.LatLng(data.Location.original_lat, data.Location.original_lng),
											heading,
											link[3]
										];
										nextLink(link);
										return;
									}
								}
							}
							
							{
								if(dist2 < coeff.minLinkRadius)
									link[3] = link[3].x(coeff.minLinkRadius/dist2);
								if(dist2 > coeff.maxLinkRadius)
									link[3] = link[3].x(coeff.maxLinkRadius/dist2);
								
								links2.push([
									link[0],
									link[3],
									normalizeRad(Math.atan2(link[3].elements[0], link[3].elements[1]))
								]);
								
								if(!--nextCtr)
									next(tryCtr2);
							}
						}
					});
				}
				nextLink(links1[i]);
			}
			
			if(!--nextCtr)
				next(tryCtr2);
		},
		
		// prepare ground, ceiling and wall textures
		
		function() {
			var tryCtr2 = tryCtr1,
				nextCtr = 1,
				callList1 = [],
				callList2 = [];
			
			function async1() {
				if(callList1.length == 0)
					return;
				
				var params = callList1.pop(),
					ceiling = params[0],
					yaws = params[1],
					pitch = params[2],
					pitch1 = params[3],
					pitch2 = params[4];
					
				for(var yaw = 0; yaw < yaws; ++yaw) {
					var pre = [
						panoImg.width / yaws,
						1 / (1 << (coeff.loadGroundPitchNum - 1)) * coeff.wallHeight / ((ceiling) ? (coeff.wallHeight - coeff.camHeight) : coeff.camHeight),
						1 / (Math.PI/2) * panoImg.height / 2,
						1 / yaws * (Math.PI*2),
						Math.cos(1 / yaws * (Math.PI*2)),
						1 / (1 << (coeff.loadGroundPitchNum - 1)) * tex2Size[0] / 2,
						[tex2Size[0] / 2,tex2Size[1] / 2]
					],
					srcCoords1 = [
						yaw * pre[0],
						(yaw+1) * pre[0],
						Math.atan(pitch1 * pre[1]) * pre[2],
						Math.atan(pitch2 * pre[1]) * pre[2]
					],
					srcCoords2 = [
						(ceiling) ? srcCoords1[2] : panoImg.height - srcCoords1[2],
						(ceiling) ? srcCoords1[3] : panoImg.height - srcCoords1[3]
					],
					srcCoords3 = [
						[srcCoords1[0], srcCoords2[0]],
						[srcCoords1[0], srcCoords2[1]],
						[srcCoords1[1], srcCoords2[1]],
						[srcCoords1[1], srcCoords2[0]]
					],
					dstCoords1 = [
						yaw * pre[3] + (Math.PI),
						(yaw+1) * pre[3] + (Math.PI),
						pitch1 * pre[5],
						pitch2 * pre[5]
					],
					dstCoords2 = [
						dstCoords1[2] * ((yaw % 2) ? pre[4] : 1),
						dstCoords1[2] * ((!(yaw % 2)) ? pre[4] : 1)
					],
					dstCoords3 = [
						radialCoord(pre[6], dstCoords1[0], dstCoords2[0], true),
						radialCoord(pre[6], dstCoords1[0], dstCoords1[3], true),
						radialCoord(pre[6], dstCoords1[1], dstCoords1[3], true),
						radialCoord(pre[6], dstCoords1[1], dstCoords2[1], true)
					];
					transformQuad1(panoImg, (ceiling) ? tex1[2] : tex1[1], [[$V(srcCoords3[0]), $V(srcCoords3[1]), $V(srcCoords3[2]), $V(srcCoords3[3])], [$V(dstCoords3[0]), $V(dstCoords3[1]), $V(dstCoords3[2]), $V(dstCoords3[3])]], !pitch);
				}
				
				setTimeout(async1, 1);
				
				if(!--nextCtr)
					next(tryCtr2);
			}
			
			for(var ceiling = 0; ceiling < 2; ++ceiling) {
				for(var pitch = 0; pitch < coeff.loadGroundPitchNum; ++pitch) {
					var pitch2 = 1 << pitch,
						pitch1 = pitch2 >> 1,
						yaws = ((qualityMode) ? coeff.loadGroundYawStartQuality : coeff.loadGroundYawStart) << pitch;
					
					nextCtr++;
					callList1.push([ceiling, yaws, pitch, pitch1, pitch2]);
				}
			}
			
			function async2() {
				if(callList2.length == 0)
					return;
				
				var params = callList2.pop(),
					pitch = params[0];
				
				for(var yaw = 0; yaw < coeff.wallNum; ++yaw) {
					var pre = [
						panoImg.width / coeff.wallNum,
						1 / (Math.PI/2) * panoImg.height / 2
					],
					srcCoords1 = [
						yaw * pre[0],
						(yaw+1) * pre[0],
						(pitch * (coeff.wallHeight / coeff.loadWallPitchNum) - coeff.camHeight),
						((pitch+1) * (coeff.wallHeight / coeff.loadWallPitchNum) - coeff.camHeight),
						walls1[yaw],
						walls1[(yaw+1) % coeff.wallNum]
					],
					srcCoords2 = [
						panoImg.height / 2 - Math.atan(srcCoords1[2] / srcCoords1[4]) * pre[1],
						panoImg.height / 2 - Math.atan(srcCoords1[3] / srcCoords1[4]) * pre[1],
						panoImg.height / 2 - Math.atan(srcCoords1[3] / srcCoords1[5]) * pre[1],
						panoImg.height / 2 - Math.atan(srcCoords1[2] / srcCoords1[5]) * pre[1]
					],
					srcCoords3 = [
						[srcCoords1[0], srcCoords2[0]],
						[srcCoords1[0], srcCoords2[1]],
						[srcCoords1[1], srcCoords2[2]],
						[srcCoords1[1], srcCoords2[3]]
					],
					dstCoords1 = [
						yaw * pre[0],
						(yaw+1) * pre[0],
						tex1Size[1] - pitch * tex1Size[1] / coeff.loadWallPitchNum,
						tex1Size[1] - (pitch+1) * tex1Size[1] / coeff.loadWallPitchNum
					],
					dstCoords2 = [
						[dstCoords1[0], dstCoords1[2]],
						[dstCoords1[0], dstCoords1[3]],
						[dstCoords1[1], dstCoords1[3]],
						[dstCoords1[1], dstCoords1[2]]
					];
					transformQuad1(panoImg, tex1[0], [[$V(srcCoords3[0]), $V(srcCoords3[1]), $V(srcCoords3[2]), $V(srcCoords3[3])], [$V(dstCoords2[0]), $V(dstCoords2[1]), $V(dstCoords2[2]), $V(dstCoords2[3])]], false);
				}
				
				setTimeout(async2, 1);
				
				if(!--nextCtr)
					next(tryCtr2);
			}
			
			for(var pitch = 0; pitch < coeff.loadWallPitchNum; ++pitch) {
				nextCtr++;
				callList2.push([pitch]);
			}
			
			setTimeout(async1, 1);
			setTimeout(async2, 1);
			
			if(!--nextCtr)
				next(tryCtr2);
		},
		
		// finish loading and initiate update
		
		function() {
			next(tryCtr1);
			
			// configure initial heading
			
			if(initialLoading) {
				var initHeading1 = deg2rad(0),
					initHeading2 = deg2rad(0),
					nearestAngle = deg2rad(90);
				switch(getParam('dir')) {
				case 'n': initHeading1 = deg2rad(0); break;
				case 'e': initHeading1 = deg2rad(90); break;
				case 's': initHeading1 = deg2rad(180); break;
				case 'w': initHeading1 = deg2rad(270); break;
				}
				initHeading1 = normalizeRad(initHeading1 - centerHeading);
				
				for(var i = 0; i < links2.length; ++i) {
					var heading = normalizeRad(Math.atan2(links2[i][1].elements[0], links2[i][1].elements[1])),
						headingAngle = Math.abs(initHeading1 - heading);
					if(headingAngle > deg2rad(180))
						headingAngle = normalizeRad(-headingAngle)
					if(nearestAngle > headingAngle) {
						nearestAngle = headingAngle;
						initHeading2 = heading;
					}
				}
				
				viewRot[1] = initHeading2;
			}
			
			// adjust view position and rotation relative to previous panorama
			
			var rotDiff = (previousCenterHeading == null) ? 0 : normalizeRad(previousCenterHeading - centerHeading);
			loadPos = viewPos = viewPos.subtract(linkPos).rotate(-rotDiff, Vector.Zero(2));
			viewRot[1] += rotDiff;
			
			// convert wall depths to coords and merge close walls
			
			var walls2 = [],
				mergeNext = false;
			for(var i = 0; i < coeff.wallNum; ++i) {
				if(mergeNext
				&& i > 0 && i < (coeff.wallNum - 1)
				&& walls1[i - 1] <= coeff.mergeWallsDist && walls1[i] <= coeff.mergeWallsDist && walls1[i + 1] <= coeff.mergeWallsDist
				&& Math.abs(walls1[i - 1] - walls1[i + 1]) <= coeff.mergeWallsTolerance) {
					mergeNext = false;
					continue;
				}
				
				walls2.push([
					radialCoord([0,0], i / coeff.wallNum * (Math.PI*2) + (Math.PI), walls1[i], false),
					i
				]);
				mergeNext = true;
			}
			
			tex2 = tex1;
			texImg2 = texImg1;
			links3 = links2;
			walls3 = walls2;
			
			initialLoading = false;
			isLoading = false;
			
			fade = true;
			setTimeout(update, 1);
		}
	];
	
	// begin with first step
	
	next(tryCtr1);
}

// display update routine

var isUpdating = false,
	requiresUpdate = false,
	updateOnce = true;

update = function() {
	
	// wait for initial loading
	
	if(initialLoading)
		return;
	
	// handle concurrent event
	
	requiresUpdate = true;
	if(isUpdating || (isLoading && !updateOnce))
		return;
	isUpdating = true;
	requiresUpdate = false;
	updateOnce = !isLoading;
	
	// update dimensions, set canvas properties
	
	var btnSize = $('body').width()/20;
	$('.btn').width(btnSize);
	$('.btn').height(btnSize);
	
	var outImg = $('#outImg')[0];
	outImg.width = 1;
	outImg.height = 1;
	var outSize = [$('#outCont').width(),$('#outCont').height()];
	
	outImg.width = outSize[0];
	outImg.height = outSize[1];
	var buf = outImg.getContext('2d');
	
	// view translation and projection matrices
	
	var dist = viewPos.distanceFrom(Vector.Zero(2));
	if(dist > coeff.maxWallRadius)
		viewPos = viewPos.x(coeff.maxWallRadius/dist);
	
	viewRot[0] = Math.max(viewRot[0], -deg2rad(90));
	viewRot[0] = Math.min(viewRot[0], deg2rad(90));
	viewRot[1] = normalizeRad(viewRot[1]);
	
	var cx = Math.cos(viewRot[0]),
		sx = Math.sin(viewRot[0]),
		cy = Math.cos(-viewRot[1]),
		sy = Math.sin(-viewRot[1]);
	
	var viewMatrix = Matrix.I(4);
	viewMatrix = viewMatrix.x($M([
		[1,0,0,0],
		[0,1,0,0],
		[0,0,1,0],
		[-viewPos.elements[0],-coeff.viewHeight,-viewPos.elements[1],1]
	]));
	viewMatrix = viewMatrix.x($M([
		[cy,0,-sy,0],
		[0,1,0,0],
		[sy,0,cy,0],
		[0,0,0,1]
	]));
	viewMatrix = viewMatrix.x($M([
		[1,0,0,0],
		[0,cx,sx,0],
		[0,-sx,cx,0],
		[0,0,0,1]
	]));
	viewMatrix = viewMatrix.x($M([
		[outSize[1]/outSize[0],0,0,0],
		[0,1,0,0],
		[0,0,1,1],
		[0,0,0,0]
	]));
	
	// build ground and ceiling, translate and rotate
	
	var ground = [];
	for(var ceiling = 0; ceiling < 2; ++ceiling) {
		var tbl = (ceiling) ? coeff.ceilingTbl : coeff.groundTbl,
			tblMax = (ceiling) ? coeff.ceilingTblMax : coeff.groundTblMax;
		for(var i = 0; i < tbl.length - 1; ++i) {
			var i1 = tbl[i],
				i2 = tbl[i + 1];
		
			for(var j = 0; j < tbl.length - 1; ++j) {
				var j1 = tbl[j],
					j2 = tbl[j + 1];
			
				var pre = [
					tex2Size[0] / 2,
					tex2Size[1] / 2,
					tex2Size[0] / (tblMax*2),
					tex2Size[1] / (tblMax*2)
				],
				srcVerts1 = [
					pre[0] + j1 * pre[2],
					pre[0] + j2 * pre[2],
					pre[1] - i1 * pre[3],
					pre[1] - i2 * pre[3],
				],
				dstVerts1 = [
					j1 * (coeff.groundRadius / tblMax),
					j2 * (coeff.groundRadius / tblMax),
					i1 * (coeff.groundRadius / tblMax),
					i2 * (coeff.groundRadius / tblMax)
				],
				dstVerts2 = [
					[dstVerts1[(ceiling) ? 1 : 0],(ceiling) ? coeff.wallHeight : 0,dstVerts1[2]],
					[dstVerts1[(ceiling) ? 1 : 0],(ceiling) ? coeff.wallHeight : 0,dstVerts1[3]],
					[dstVerts1[(ceiling) ? 0 : 1],(ceiling) ? coeff.wallHeight : 0,dstVerts1[3]],
					[dstVerts1[(ceiling) ? 0 : 1],(ceiling) ? coeff.wallHeight : 0,dstVerts1[2]]
				];
				for(var k = 0; k < 4; ++k) {
					var tmp = dstVerts2[k];
					tmp[3] = 1;
					tmp = $M([tmp]);
					tmp = tmp.x(viewMatrix);
					tmp = tmp.elements[0];
					dstVerts2[k] = $V([
						tmp[0],
						tmp[1],
						tmp[2]
					]);
				}
			
				if(dstVerts2[0].elements[2] <= 1
				&& dstVerts2[1].elements[2] <= 1
				&& dstVerts2[2].elements[2] <= 1
				&& dstVerts2[3].elements[2] <= 1)
					continue;
			
				ground.push([
					[
						$V([srcVerts1[(ceiling) ? 1 : 0],srcVerts1[2]]),
						$V([srcVerts1[(ceiling) ? 1 : 0],srcVerts1[3]]),
						$V([srcVerts1[(ceiling) ? 0 : 1],srcVerts1[3]]),
						$V([srcVerts1[(ceiling) ? 0 : 1],srcVerts1[2]])
					],
					dstVerts2,
					(ceiling) ? 2 : 1
				]);
			}
		}
	}
	
	// build walls, translate and rotate
	
	var walls4 = [];
	for(var i = 0; i < walls3.length; ++i) {
		var srcVerts = [
			walls3[i][1] * tex1Size[0] / coeff.wallNum,
			((walls3[(i + 1) % walls3.length][1] + coeff.wallNum - 1) % coeff.wallNum + 1) * tex1Size[0] / coeff.wallNum,
			tex1Size[1],
			tex1Size[1] * 2 / 3,
			0
		],
		dstVerts1 = [
			[walls3[i][0][0],0,walls3[i][0][1]],
			[walls3[i][0][0],coeff.wallHeight,walls3[i][0][1]],
			[walls3[(i + 1) % walls3.length][0][0],coeff.wallHeight,walls3[(i + 1) % walls3.length][0][1]],
			[walls3[(i + 1) % walls3.length][0][0],0,walls3[(i + 1) % walls3.length][0][1]],
		],
		dstVec = [
			$V(dstVerts1[0]),
			$V(dstVerts1[3]),
			$V(dstVerts1[1]).subtract($V(dstVerts1[0])).x(1/3),
			$V(dstVerts1[2]).subtract($V(dstVerts1[3])).x(1/3)
		],
		dstVerts2 = [
			[
				dstVec[2].x(0).add(dstVec[0]),
				dstVec[2].x(1).add(dstVec[0]),
				dstVec[3].x(1).add(dstVec[1]),
				dstVec[3].x(0).add(dstVec[1])
			],
			[
				dstVec[2].x(1).add(dstVec[0]),
				dstVec[2].x(3).add(dstVec[0]),
				dstVec[3].x(3).add(dstVec[1]),
				dstVec[3].x(1).add(dstVec[1])
			]
		];
		
		for(var j = 0; j < 2; ++j) {
			for(var k = 0; k < 4; ++k) {
				var tmp = dstVerts2[j][k].elements;
				tmp[3] = 1;
				tmp = $M([tmp]);
				tmp = tmp.x(viewMatrix);
				tmp = tmp.elements[0];
				dstVerts2[j][k] = $V([
					tmp[0],
					tmp[1],
					tmp[2]
				]);
			}
			
			if(dstVerts2[j][0].elements[2] <= 1
			&& dstVerts2[j][1].elements[2] <= 1
			&& dstVerts2[j][2].elements[2] <= 1
			&& dstVerts2[j][3].elements[2] <= 1)
				continue;
			
			walls4.push([
				[
					$V([srcVerts[0], (j) ? srcVerts[3] : srcVerts[2]]),
					$V([srcVerts[0], (j) ? srcVerts[4] : srcVerts[3]]),
					$V([srcVerts[1], (j) ? srcVerts[4] : srcVerts[3]]),
					$V([srcVerts[1], (j) ? srcVerts[3] : srcVerts[2]])
				],
				dstVerts2[j],
				0
			]);
		}
	}
	
	// z-sort walls
	
	walls4 = walls4.sort(function(a,b){
		za = (a[1][0].elements[2] + a[1][1].elements[2] + a[1][2].elements[2] + a[1][3].elements[2]) / 4;
		zb = (b[1][0].elements[2] + b[1][1].elements[2] + b[1][2].elements[2] + b[1][3].elements[2]) / 4;
		return zb - za;
	});
	
	// merge ground, ceiling and wall quads, split to triangles and segment
	
	var quads = ground.concat(walls4);
	if(qualityMode)
		quads = qualitySegment(quads);
	for(var i = 0; i < quads.length; ++i) {
		var srcVert = quads[i][0],
			dstVert = quads[i][1],
			srcMiddle1 = srcVert[0].add(srcVert[1]).add(srcVert[2]).add(srcVert[3]).x(1/4),
			dstMiddle1 = dstVert[0].add(dstVert[1]).add(dstVert[2]).add(dstVert[3]).x(1/4),
			srcVerts1 = [],
			dstVerts1 = [];
		srcVerts1.push([srcVert[0], srcVert[1], srcMiddle1]);
		srcVerts1.push([srcVert[1], srcVert[2], srcMiddle1]);
		srcVerts1.push([srcVert[2], srcVert[3], srcMiddle1]);
		srcVerts1.push([srcVert[3], srcVert[0], srcMiddle1]);
		dstVerts1.push([dstVert[0], dstVert[1], dstMiddle1]);
		dstVerts1.push([dstVert[1], dstVert[2], dstMiddle1]);
		dstVerts1.push([dstVert[2], dstVert[3], dstMiddle1]);
		dstVerts1.push([dstVert[3], dstVert[0], dstMiddle1]);
		
		var srcVerts2 = [],
			dstVerts2 = [];
		for(var j = 0; j < dstVerts1.length; ++j) {
			if(dstVerts1[j][0].elements[2] <= coeff.segmentNearDist
			|| dstVerts1[j][1].elements[2] <= coeff.segmentNearDist
			|| dstVerts1[j][2].elements[2] <= coeff.segmentNearDist) {
				var srcMiddle2 = [
						srcVerts1[j][0].add(srcVerts1[j][1]).x(1/2),
						srcVerts1[j][1].add(srcVerts1[j][2]).x(1/2),
						srcVerts1[j][2].add(srcVerts1[j][0]).x(1/2)
					],
					dstMiddle2 = [
						dstVerts1[j][0].add(dstVerts1[j][1]).x(1/2),
						dstVerts1[j][1].add(dstVerts1[j][2]).x(1/2),
						dstVerts1[j][2].add(dstVerts1[j][0]).x(1/2)
					];
				srcVerts2.push([
					srcMiddle2[0],
					srcMiddle2[2],
					srcVerts1[j][0]
				]);
				srcVerts2.push([
					srcMiddle2[1],
					srcMiddle2[0],
					srcVerts1[j][1]
				]);
				srcVerts2.push([
					srcMiddle2[2],
					srcMiddle2[1],
					srcVerts1[j][2]
				]);
				srcVerts2.push([
					srcMiddle2[0],
					srcMiddle2[1],
					srcMiddle2[2]
				]);
				dstVerts2.push([
					dstMiddle2[0],
					dstMiddle2[2],
					dstVerts1[j][0]
				]);
				dstVerts2.push([
					dstMiddle2[1],
					dstMiddle2[0],
					dstVerts1[j][1]
				]);
				dstVerts2.push([
					dstMiddle2[2],
					dstMiddle2[1],
					dstVerts1[j][2]
				]);
				dstVerts2.push([
					dstMiddle2[0],
					dstMiddle2[1],
					dstMiddle2[2]
				]);
			}
			else {
				srcVerts2.push(srcVerts1[j]);
				dstVerts2.push(dstVerts1[j]);
			}
		}
		
		// clip near
		
		var srcVerts3 = [],
			dstVerts3 = [];
		for(var j = 0; j < dstVerts2.length; ++j) {
			if(dstVerts2[j][0].elements[2] <= 1
			&& dstVerts2[j][1].elements[2] <= 1
			&& dstVerts2[j][2].elements[2] <= 1)
				continue;
			
			if(dstVerts2[j][0].elements[2] <= 1
			|| dstVerts2[j][1].elements[2] <= 1
			|| dstVerts2[j][2].elements[2] <= 1) {
				var mode,
					srcClip1,
					dstClip1;
				if(dstVerts2[j][0].elements[2] <= 1
				&& dstVerts2[j][1].elements[2] <= 1) {
					mode = 0;
					srcClip1 = [srcVerts2[j][0], srcVerts2[j][1], srcVerts2[j][2]];
					dstClip1 = [dstVerts2[j][0], dstVerts2[j][1], dstVerts2[j][2]];
				}
				else if(dstVerts2[j][1].elements[2] <= 1
				&& dstVerts2[j][2].elements[2] <= 1) {
					mode = 0;
					srcClip1 = [srcVerts2[j][1], srcVerts2[j][2], srcVerts2[j][0]];
					dstClip1 = [dstVerts2[j][1], dstVerts2[j][2], dstVerts2[j][0]];
				}
				else if(dstVerts2[j][2].elements[2] <= 1
				&& dstVerts2[j][0].elements[2] <= 1) {
					mode = 0;
					srcClip1 = [srcVerts2[j][2], srcVerts2[j][0], srcVerts2[j][1]];
					dstClip1 = [dstVerts2[j][2], dstVerts2[j][0], dstVerts2[j][1]];
				}
				else if(dstVerts2[j][0].elements[2] <= 1) {
					mode = 1;
					srcClip1 = [srcVerts2[j][1], srcVerts2[j][2], srcVerts2[j][0]];
					dstClip1 = [dstVerts2[j][1], dstVerts2[j][2], dstVerts2[j][0]];
				}
				else if(dstVerts2[j][1].elements[2] <= 1) {
					mode = 1;
					srcClip1 = [srcVerts2[j][2], srcVerts2[j][0], srcVerts2[j][1]];
					dstClip1 = [dstVerts2[j][2], dstVerts2[j][0], dstVerts2[j][1]];
				}
				else if(dstVerts2[j][2].elements[2] <= 1) {
					mode = 1;
					srcClip1 = [srcVerts2[j][0], srcVerts2[j][1], srcVerts2[j][2]];
					dstClip1 = [dstVerts2[j][0], dstVerts2[j][1], dstVerts2[j][2]];
				}
				
				try {
					var srcVec = [
						srcClip1[0].subtract(srcClip1[2]),
						srcClip1[1].subtract(srcClip1[2]),
						srcClip1[2]
					],
					dstVec = [
						Plane.XY.translate(Vector.k).intersectionWith($L(dstClip1[2],dstClip1[0].subtract(dstClip1[2]))),
						Plane.XY.translate(Vector.k).intersectionWith($L(dstClip1[2],dstClip1[1].subtract(dstClip1[2])))
					],
					dstClip2 = [
						dstVec[0],
						dstVec[1],
						dstClip1[2]
					],
					dist = [
						Math.min(dstClip2[0].distanceFrom(dstClip2[2]) / dstClip1[0].distanceFrom(dstClip1[2]),1),
						Math.min(dstClip2[1].distanceFrom(dstClip2[2]) / dstClip1[1].distanceFrom(dstClip1[2]),1)
					],
					srcClip2 = [
						srcVec[0].x(dist[0]).add(srcVec[2]),
						srcVec[1].x(dist[1]).add(srcVec[2]),
						srcClip1[2]
					];
					if(!mode) {
						srcVerts3.push(srcClip2);
						dstVerts3.push(dstClip2);
					}
					else {
						var srcMiddle3 = srcClip2[0].add(srcClip2[1]).x(1/2),
							dstMiddle3 = dstClip2[0].add(dstClip2[1]).x(1/2);
						srcVerts3.push([
							srcClip2[0],
							srcClip1[0],
							srcMiddle3
						]);
						srcVerts3.push([
							srcClip1[1],
							srcClip2[1],
							srcMiddle3
						]);
						srcVerts3.push([
							srcClip1[0],
							srcClip1[1],
							srcMiddle3
						]);
						dstVerts3.push([
							dstClip2[0],
							dstClip1[0],
							dstMiddle3
						]);
						dstVerts3.push([
							dstClip1[1],
							dstClip2[1],
							dstMiddle3
						]);
						dstVerts3.push([
							dstClip1[0],
							dstClip1[1],
							dstMiddle3
						]);
					}
				}
				catch(e) { }
			}
			else {
				srcVerts3.push(srcVerts2[j]);
				dstVerts3.push(dstVerts2[j]);
			}
		}
		
		// convert triangles to viewport coordinates and draw to buffer
		// assume near clipped
		// cull viewport and backface
		
		for(var j = 0; j < dstVerts3.length; ++j) {
			var dstCoords = [];
			for(var k = 0; k < 3; ++k) {
				var depth = Math.max(dstVerts3[j][k].elements[2], 1);
				dstCoords[k] = [
					outSize[0]/2+dstVerts3[j][k].elements[0]/depth*outSize[0]/2,
					outSize[1]/2-dstVerts3[j][k].elements[1]/depth*outSize[1]/2
				];
			}
			
			if(dstCoords[0][0] < 0
			&& dstCoords[1][0] < 0
			&& dstCoords[2][0] < 0)
				continue;
			
			if(dstCoords[0][0] >= outSize[0]
			&& dstCoords[1][0] >= outSize[0]
			&& dstCoords[2][0] >= outSize[0])
				continue;
			
			if(dstCoords[0][1] < 0
			&& dstCoords[1][1] < 0
			&& dstCoords[2][1] < 0)
				continue;
			
			if(dstCoords[0][1] >= outSize[1]
			&& dstCoords[1][1] >= outSize[1]
			&& dstCoords[2][1] >= outSize[1])
				continue;
			
			var normal = $V([dstCoords[2][0]-dstCoords[0][0],dstCoords[2][1]-dstCoords[0][1],0]).cross($V([dstCoords[1][0]-dstCoords[0][0],dstCoords[1][1]-dstCoords[0][1],0]));
			if(normal.elements[2] > 0)
				continue;
			
			transformTriangle(texImg2[quads[i][2]], buf, [srcVerts3[j], [$V(dstCoords[0]), $V(dstCoords[1]), $V(dstCoords[2])]], true);
		}
	}
	
	// draw compass to buffer
	
	var nearestAngle = coeff.loadTolerance,
		selectedHeading = -1;
	for(var i = 0; i < links3.length; ++i) {
		var heading = normalizeRad(coeff.loadTolerance + links3[i][2] - viewRot[1]),
			headingAngle = Math.abs(heading - coeff.loadTolerance);
		if(nearestAngle > headingAngle) {
			nearestAngle = headingAngle;
			selectedHeading = i;
		};
	}
	
	for(var i = 0; i < links3.length; ++i) {
		var heading = normalizeRad(coeff.compassTolerance + links3[i][2] - viewRot[1]),
			front = false,
			linkSize,
			linkCoords;
		
		if(heading < (coeff.compassTolerance*2)) {
			front = true;
			linkSize = outSize[1] / coeff.compassSizeQuota;
			linkCoords = [
				heading / (coeff.compassTolerance*2) * outSize[0],
				outSize[1] - (linkSize*2),
				1
			];
		}
		else {
			linkSize = outSize[1] / (coeff.compassSizeQuota << 1);
			linkCoords = [
				normalizeRad(-heading) / normalizeRad(-coeff.compassTolerance*2) * outSize[0],
				outSize[1] - linkSize*3,
				-1
			];
		}
	
		var scale = (loadDist / coeff.maxLoadDist) + 1;
		var dist = (loadPos.distanceFrom(links3[i][1]) - loadPos.distanceFrom(Vector.Zero(2))) / scale;
		dist = Math.ceil(dist);
		dist = Math.max(dist, 0);
		
		buf.save();
		buf.translate(linkCoords[0],linkCoords[1]);
		
		buf.fillStyle = (front && !dist && selectedHeading == i) ? '#fff' : '#0f0';
		buf.strokeStyle = '#000';
		buf.lineWidth = 1;
		buf.beginPath();
		buf.moveTo(0,(-linkSize*2)*linkCoords[2]);
		buf.lineTo(linkSize,0);
		buf.lineTo(-linkSize,0);
		buf.closePath();
		buf.fill();
		buf.stroke();
		
		if(front) {
			buf.fillStyle = '#fff';
			buf.font = 'bold ' + (linkSize*3/4) + 'px sans-serif';
			buf.textAlign = 'center';
			buf.textBaseline = 'middle';
			buf.fillText(dist,0,(-linkSize/2)*linkCoords[2]);
		}
		
		buf.restore();
	}
	
	// fade output image
	
	if(fade) {
		$('#outImg').finish();
		$('#outImg').fadeTo(500,1);
		fade = false;
	}
	
	// repeat after concurrent event
	
	isUpdating = false;
	if(requiresUpdate)
		setTimeout(update, 1);
}

// key and event handlers

var isMoving = false,
	isLooking = false,
	lookAccel = false,
	pressed = {},
	pressedOnce = {},
	pressedTimer = false;
function move(x,z,loadDistAhead) {
	isMoving = true;
	
	var loadSpeed = Math.max((loadDistAhead) ? loadDist : loadDist / coeff.loadDistSideQuota, coeff.moveSpeed + 1),
		vec = $V([x,z]).rotate(-viewRot[1], Vector.Zero(2));

	viewPos = viewPos.add(vec.x(coeff.moveSpeed));
	loadDistPos = loadDistPos.add(vec.x(coeff.moveSpeed));
	loadPos = loadPos.add(vec.x(loadSpeed));
	
	setTimeout(load, 1);
}

function handlePressed() {
	isMoving = false;
	isLooking = false;
	loadPos = viewPos;
	
	var isPressed = false;
	for(var key in pressed) {
		if(pressed[key])
			pressedOnce[key] = true;
	}
	for(var key in pressedOnce) {
		if(pressedOnce[key]) {
			isPressed = true;
			if(!isLoading) {
				switch(parseInt(key)) {
				case 87: // w
					move(0,1,true);
				break;
				case 65: // a
					move(-1,0,false);
				break;
				case 83: // s
					move(0,-1,false);
				break;
				case 68: // d
					move(1,0,false);
				break;
				case 37: // left
					isLooking = true;
					viewRot[1] -= (lookAccel) ? coeff.viewYawStepAccel : coeff.viewYawStep;
				break;
				case 38: // up
					viewRot[0] -= coeff.viewPitchStep;
				break;
				case 39: // right
					isLooking = true;
					viewRot[1] += (lookAccel) ? coeff.viewYawStepAccel : coeff.viewYawStep;
				break;
				case 40: // down
					viewRot[0] += coeff.viewPitchStep;
				break;
				}
			}
		}
	}
	
	if(!isMoving)
		loadDistPos = Vector.Zero(2);
	loadDist = loadDistPos.distanceFrom(Vector.Zero(2)) / coeff.loadDistQuota;
	loadDist = Math.min(loadDist,coeff.maxLoadDist);
	
	lookAccel = isLooking;
	
	pressedOnce = [];
	if(isPressed){
		setTimeout(handlePressed, coeff.keyInterval);
		
		if(!isLoading)
			setTimeout(update, 1);
	}
	else {
		pressedTimer = false;
	}
}

keydownHandler = function(key) {
	switch(key) {
	case 87: // w
	case 65: // a
	case 83: // s
	case 68: // d
	case 37: // left
	case 38: // up
	case 39: // right
	case 40: // down
		pressed[key] = true;
		pressedOnce[key] = true;
		if(!pressedTimer) {
			pressedTimer = true;
			setTimeout(handlePressed, 1);
		}
	}
}
$(window).keydown(function(e) {
	keydownHandler(e.which);
});

keyupHandler = function(key) {
	switch(key) {
	case 87: // w
	case 65: // a
	case 83: // s
	case 68: // d
	case 37: // left
	case 38: // up
	case 39: // right
	case 40: // down
		pressed[key] = false;
	}
}
$(window).keyup(function(e) {
	keyupHandler(e.which);
});

$(window).resize(function() {
	setTimeout(update, 1);
});

$(window).error(function() {
	failed = true;
	if(!abortOnFail) {
		$('#fail_gen').show();
		$('#outImg').hide();
	}
});

// run!

setTimeout(load, 1);

});
</script>
</body>
</html>
